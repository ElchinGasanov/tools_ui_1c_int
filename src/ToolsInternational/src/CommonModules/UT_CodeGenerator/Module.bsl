
#Region Public


// Standard header of the generated code.
// 
// Parameters:
//  Tool - String- Tool
//  ToolFileName - String -  Имя файла
//  NameOfGeneratedRecord - String -Имя генерируемой записи
//  AdditionalData - Соответствие из КлючИЗначение:
//  	* Key - String - Имя 
//  	* Value - String - 
// Return values:
//  String
Function StandardGeneratedCodeHeader(Tool, ToolFileName = "", NameOfGeneratedRecord = "",
	AdditionalData = Undefined) Export
	TextAdditionalData = "";
	If AdditionalData <> Undefined Then
		RowsToConcatenate = New Array;
		For Each  KeyValue Из AdditionalData Do
			RowsToConcatenate.Add(StrTemplate("//%1 - %2", KeyValue.Key, KeyValue.Value));
		EndDo;

		TextAdditionalData = StrConcat(RowsToConcatenate, Chars.LF);
	EndIf;
	
	Return StrTemplate("//Generated by tool ""%4"" from the set ""1C Universal tools""
					  |//https://github.com/i-neti/tools_ui_1c_int
					  |//
					  |//Data - %1
					  |//Tool file name - %2
					  |//Name - %3
					  |//User - %5
					  |%6
					  |",
					  CurrentSessionDate(),
					  ToolFileName,
					  NameOfGeneratedRecord,
					  Tool,
					  UserName(),
					  TextAdditionalData);
EndFunction

// Value in code string.
// 
// Parameters:
//  Value - Custom - Value
//  NameOfVariableToFill - String -  Имя переменной при необходиости. Используется только For сложных типов, 
//  	которые нужно заполнять с отдельным объявлением переменной
// 
// Return values:
//  String - Value in code string
Function ValueInCodeString(Value, NameOfVariableToFill = "") Export
	ValueType = TypeOf(Value);
	
	If ValueType = Тип("Boolean") Then
		Return BooleanInCodeString(Value);
	ElsIf ValueType = Тип("Number") Then 
		Return NumberInCodeString(Value);
	ElsIf ValueType = Тип("String") Then 
		Return StringInCodeString(Value);
	ElsIf ValueType = Тип("Date") Then 
		Return DateInCodeString(Value);
	ElsIf ValueType = Тип("Undefined") Then 
		Return UndefinedInCodeString();
	ElsIf ValueType = Тип("Null") Then 
		Return NullInCodeString();
	ElsIf ValueType = Тип("UUID") Then 
		Return UUIDInCodeString(Value);
//	ElsIf ValueType = Тип("Тип") Then 
//		Return ТипВСтокуКода(Value);
	ElsIf ValueType = Тип("PointInTime") Then 
		Return PointInTimeInCodeString(Value);
	ElsIf ValueType = Тип("Boundary") Then
		Return BoundaryInCodeString(Value);
	ElsIf ValueType = Тип("BinaryData") Then 
		Return BinaryDataInCodeString(Value);
	ElsIf ValueType = Тип("Picture") Then 
		Return PictureInCodeString(Value);
	ElsIf ValueType = Тип("Array") Then 
		Return ArrayInCodeString(Value, NameOfVariableToFill);
	ElsIf ValueType = Тип("ValueList") Then 
		Return ValueListInCodeString(Value, NameOfVariableToFill);
	ElsIf UT_Common.IsReference(ValueType) Then 
		Return RefInCodeString(Value);
	Else
		Return NStr("ru = '???//Тип'; en = 'Type'") + " " + ValueType + NStr("ru = ' пока не поддерживается For генерации'; en = ' not yet supported for generation'");
	EndIf;
EndFunction

#Region PrimitiveTypes

// Boolean in code string.
// 
// Parameters:
//  Value - Boolean - Значение
// 
// Return values:
// String
Function BooleanInCodeString(Value) Export
	Return Format(Value, "BF=False; BT=True;");
EndFunction

// Number in code string.
// 
// Parameters:
//  Value - Number - Value
// 
// Return values:
// String -  Number in code string
Function NumberInCodeString(Value) Export
	Return NumberInStringWithoutNonBreakingSpaces(Value);
EndFunction

// String in code string.
// 
// Parameters:
//  Value - String - Значение
// 
// Return values:
// String
Function StringInCodeString(Value) Export
	StringForConfigurator = StrReplace(Value, """", """""");
	StringForConfigurator = StrReplace(StringForConfigurator, Chars.LF, Chars.LF + "|");
	Return """" + StringForConfigurator + """";
EndFunction

// Undefined in code string.
// 
// Return values:
// String -  Undefined in code string
Function UndefinedInCodeString() Export
	Return "Undefined";	
EndFunction

// Null in code string.
// 
// Return values:
// String -  Null in code string
Function NullInCodeString() Export
	Return "Null";
EndFunction

// Date in code string.
// 
// Parameters:
//  Value - Date - 
// 
// Return values:
// String - Date in code string
Function DateInCodeString(Value) Export
	If Value = BegOfDay(Value) Then
		FormatString = "DF=yyyyMMdd;";
	Else
		FormatString = "DF=yyyyMMddHHmmss;";
	EndIf;
	Return "'" + Format(Value, FormatString) + "'";
EndFunction

#EndRegion

#Region SimpleTypes

// UUID in code string.
// 
// Parameters:
//  Value - UUID
// 
// Return values:
// String -  UUID in code string
Function UUIDInCodeString(Value) Export
	Return StrTemplate("New UUID(%1)", StringInCodeString(String(Value)));
EndFunction

// Тип в стоку кода.
// 
// Parameters:
//  Value - Тип
// 
// Return values:
// String
//Function ТипВСтокуКода(Значение) Export
//	
//	ИмяТипа = УИ_ОбщегоНазначения.ИмяТипа(Значение);
//	Return StrTemplate("Тип(%1)", StringInCodeString(ИмяТипа));
//EndFunction

// PointInTime in code string.
// 
// Parameters:
//  Value - PointInTime - Value
// 
// Return values:
// String -  PointInTime in code string
Function PointInTimeInCodeString(Value) Export
	Return StrTemplate("New PointInTime(%1, %2)",
					  DateInCodeString(Value.Date),
					  ValueInCodeString(Value.Ref));

EndFunction

// Boundary in code string.
// 
// Parameters:
//  Value - Boundary
// 
// Return values:
// String -  Boundary in code string
Function BoundaryInCodeString(Value) Export
	ValuesTypeBoundaryByString = "Including";
	If Value.BoundaryType = BoundaryType.Excluding Then
		ValuesTypeBoundaryByString = "Excluding";
	EndIf;

	Return StrTemplate("New Boundary(%1, BoundaryType.%2)", DateInCodeString(Value.Value), ValuesTypeBoundaryByString);
EndFunction

// BinaryData in code string.
// 
// Parameters:
//  Value - BinaryData
// 
// Return values:
// String
Function BinaryDataInCodeString(Value) Export
	Return StrTemplate("Base64Value(%1)",StringInCodeString(Base64Строка(Value)));
EndFunction

// Picture in code string.
// 
// Parameters:
//  Value - Picture - Value
// 
// Return values:
// String
Function PictureInCodeString(Value) Export
	If Value = New Picture Then
		Return "New Picture";
	Else
		Return StrTemplate("New Picture(%1)", BinaryDataInCodeString(Value.GetBinaryData()));
	EndIf;
EndFunction

#EndRegion

#Region CollectionsValues

// Array in code string.
// 
// Parameters:
//  Value - Array of Custom
//  NameOfVariableToFill - String
// 
// Return values:
// String
Function ArrayInCodeString(Value, NameOfVariableToFill) Export
	ArrayVariableName = NameOfVariableToFill;
	If Не ValueIsFilled(ArrayVariableName) Then
		ArrayVariableName = RandomVariableName("Массив");
	EndIf;
	ArrayString = New Array;
	
	ArrayString.Add(StrTemplate("%1 = New Array;", ArrayVariableName));
	
	
	For ItemIndexValues = 0 To Value.Count() - 1 Do
		CurrentElementValues = Value[ItemIndexValues];

		NeedSeparateVariable = GeneratedCodeByTypeContainsSeveralLinesOfCode(TypeOf(CurrentElementValues));

		If Not NeedSeparateVariable Then
			ArrayString.Add(StrTemplate("%1.Add(%2);",
										   ArrayVariableName,
										   ValueInCodeString(CurrentElementValues)));
		Else
			ItemsValueVariableName = ArrayVariableName
											+ "_"
											+ NumberInStringWithoutNonBreakingSpaces(ItemIndexValues);
			ArrayString.Add(StrTemplate("
										   |%1
										   |%2.Add(%3);",
										   ValueInCodeString(CurrentElementValues, ItemsValueVariableName),
										   ArrayVariableName,
										   ItemsValueVariableName));
		EndIf;
	EndDo;
	
	Return StrConcat(ArrayString, Chars.LF);
EndFunction

// Список значений in code string.
// 
// Parameters:
//  Value - СписокЗначений из Произвольный
//  NameOfVariableToFill - String
// 
// Return values:
// String
Function ValueListInCodeString(Value, NameOfVariableToFill) Export
	VariableName = NameOfVariableToFill;
	If Not ValueIsFilled(VariableName) Then
		VariableName = RandomVariableName("ValueList");
	EndIf;
	
	EmptyPicture = New Picture;
	
	ArrayString = New Array;

	ArrayString.Add(StrTemplate("%1 = New ValueList;", VariableName));
	
	For ItemIndexValues = 0 По Value.Count() - 1 Do
		CurrentElementValues = Value[ItemIndexValues];

		ViewCode = "";
		If ValueIsFilled(CurrentElementValues.Presentation) Then
			ViewCode = StringInCodeString(CurrentElementValues.Presentation);
		EndIf;
		
		CheckСode = "";
		If CurrentElementValues.Check Then
			CheckСode = BooleanInCodeString(CurrentElementValues.Check);
		EndIf;

		PicturesCode = "";
		If CurrentElementValues.Picture <> EmptyPicture Then
			PicturesCode = PictureInCodeString(CurrentElementValues.Picture);
		EndIf;

		ItemsCodeAdditionalData = "";
		If ValueIsFilled(PicturesCode) Then
			ItemsCodeAdditionalData = StrTemplate(",%1,%2,%3", ViewCode, CheckСode, PicturesCode);
		ElsIf ValueIsFilled(CheckСode) Then
			ItemsCodeAdditionalData = StrTemplate(",%1,%2", ViewCode, CheckСode);
		ElsIf ValueIsFilled(ViewCode) Then 
			ItemsCodeAdditionalData = ","+ViewCode;
		EndIf;
		
		NeedSeparateVariable = GeneratedCodeByTypeContainsSeveralLinesOfCode(TypeOf(CurrentElementValues.Value));

		If Not NeedSeparateVariable Then
			ArrayString.Add(StrTemplate("%1.Add(%2%3);",
										   VariableName,
										   ValueInCodeString(CurrentElementValues.Value),
										   ItemsCodeAdditionalData));
		Else
			ItemsValueVariableName = VariableName
											+ "_"
											+ NumberInStringWithoutNonBreakingSpaces(ItemIndexValues);
			ArrayString.Add(StrTemplate("
										   |%1
										   |%2.Add(%3%4);",
										   ValueInCodeString(CurrentElementValues, ItemsValueVariableName),
										   VariableName,
										   ItemsValueVariableName,
										   ItemsCodeAdditionalData));
		EndIf;
	EndDo;
	
	Return StrConcat(ArrayString, Chars.LF);	
EndFunction

#EndRegion

#Region Reference

// Reference in code string.
// 
// Parameters:
//  Value - Any Reference
// 
// Return values:
// String
Function RefInCodeString(Value) Export
	MetadataLinks = Value.Metadata();
	
	MayBePredetermined = True;
	If Metadata.Catalogs.Contains(MetadataLinks) Then
		ManagerName = "Catalogs";
	ElsIf Metadata.Documents.Contains(MetadataLinks) Then 
		MayBePredetermined = False;
		ManagerName = "Documents";
	ElsIf Metadata.Enums.Contains(MetadataLinks) Then 
		Manager = Enums[MetadataLinks.Name];
		EnumerationID = MetadataLinks.EnumValues.Get(Manager.IndexOf(Value)).Name;
		
		Return StrTemplate("%1.%2.%3", "Enums", MetadataLinks.Name, EnumerationID);
	ElsIf Metadata.ChartsOfCharacteristicTypes.Contains(MetadataLinks) Then 
		ManagerName = "ChartsOfCharacteristicTypes";
	ElsIf Metadata.ChartsOfAccounts.Contains(MetadataLinks) Then 
		ManagerName = "ChartsOfAccounts";
	ElsIf Metadata.ChartsOfCalculationTypes.Contains(MetadataLinks) Then 
		ManagerName = "ChartsOfCalculationTypes";
	ElsIf Metadata.BusinessProcesses.Contains(MetadataLinks) Then 
		ManagerName = "BusinessProcesses";
		MayBePredetermined = False;
	ElsIf Metadata.Tasks.Contains(MetadataLinks) Then 
		ManagerName = "Tasks";
		MayBePredetermined = False;
	ElsIf Metadata.ExchangePlans.Contains(MetadataLinks) Then 
		ManagerName = "ExchangePlans";
		MayBePredetermined = False;
	Else
		Return "???//Неизвестный тип ссылки" + UT_Common.TypeName(TypeOf(Value));
	EndIf;
	
	If MayBePredetermined Then
		If Value.Predefined Then
			Return StrTemplate("%1.%2.%3", ManagerName, MetadataLinks.Name, Value.PredefinedDataName);
		EndIf;
	EndIf;

	Return StrTemplate("%1.%2.GetRef(%3)",
					  ManagerName,
					  MetadataLinks.Name,
					  UUIDInCodeString(Value.UUID()))
EndFunction

#EndRegion

#Region SystemEnumerations

#EndRegion

#EndRegion

#Region Internal

// Code of procedures and functions

#EndRegion

#Region Private

Function GeneratedCodeByTypeContainsSeveralLinesOfCode(Type)
	Description = DescriptionOfTypesDefinedBySeveralLinesOfCode();
	Return Description.ContainsType(Type);
EndFunction

// Types defined in a few lines of code.
// 
// Return values:
//  TypeDescription
Function DescriptionOfTypesDefinedBySeveralLinesOfCode()
	Return New TypeDescription("Array, ValueList");
EndFunction

// Random variable name.
// 
// Parameters:
//  Prefix - String
// 
// Return values:
// String
Function RandomVariableName(Prefix) 
	Return Prefix + StrReplace(New UUID, "-", "_");
EndFunction

// Number to string without non-breaking spaces.
// 
// Parameters:
//  Value - Number - Value
// 
// Return values:
// String
Function NumberInStringWithoutNonBreakingSpaces(Value)
	Return XMLString(Value);
EndFunction

#EndRegion
