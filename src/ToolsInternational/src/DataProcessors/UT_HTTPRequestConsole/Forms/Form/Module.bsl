#Область ОписаниеПеременных

&НаКлиенте
Перем УИ_ИдентификаторТекущейСтрокиЗапросов; //Число

#EndRegion

#Область ОбработчикиСобытийФормы

&AtServer
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	НачальныйЗаголовок = Заголовок;

	ИнициализироватьФорму();


	Если Параметры.Свойство("ДанныеОтладки") Then
		//@skip-check unknown-form-parameter-access
		ЗаполнитьПоДаннымОтладки(Параметры.ДанныеОтладки);
	EndIf;

	УИ_ОбщегоНазначения.ФормаИнструментаПриСозданииНаСервере(ЭтотОбъект,
															 Отказ,
															 СтандартнаяОбработка,
															 КоманднаяПанель);

КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	ОбновитьЗаголовок();
	УстановитьСтраницуРедактированияЗаголовковЗапроса();

	Если ValueIsFilled(RequestsFileName) Then
		ЗагрузитьФайлКонсоли(True);
	EndIf;
КонецПроцедуры

&AtServer
Процедура ПриЗагрузкеДанныхИзНастроекНаСервере(Настройки)
	Если Параметры.Свойство("ДанныеОтладки") Then
		RequestsFileName = "";
	EndIf;
КонецПроцедуры

#EndRegion

#Область ОбработчикиСобытийЭлементовШапкиФормы

#Область ЗаголовкиЗапроса

&НаКлиенте
Процедура EditHeadersWithTableOnChange(Элемент)
	УстановитьСтраницуРедактированияЗаголовковЗапроса();
КонецПроцедуры

#EndRegion


&НаКлиенте
Процедура RequestBodyEncodingOnChange(Item)
	УстановитьЗаголовкиПоСодержимомуТелаЗапроса();
КонецПроцедуры

&НаКлиенте
Процедура RequestsTreeTypeOfStringContentOnChange(Item)
	УстановитьЗаголовкиПоСодержимомуТелаЗапроса();
КонецПроцедуры

&НаКлиенте
Процедура RequestBodyTypeOnChange(Item)
	ПриИзмененииВидаТелаЗапроса();

КонецПроцедуры

&НаКлиенте
Процедура ИмяФайлаТелаЗапросаНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	СтрокаЗапроса = ТекущаяСтрокаЗапросов();	
	Если СтрокаЗапроса = Неопределено Then
		Return;
	EndIf;
	
	ДВФ = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	ДВФ.МножественныйВыбор = Ложь;
	ДВФ.ПолноеИмяФайла = СтрокаЗапроса.NameФайлаТела;

	ПараметрыОповещения = Новый Структура;
	ПараметрыОповещения.Вставить("RowID", СтрокаЗапроса.ПолучитьИдентификатор());

	ДВФ.Показать(Новый ОписаниеОповещения("ИмяФайлаТелаЗапросаНачалоВыбораЗавершение", ЭтотОбъект, ПараметрыОповещения));
КонецПроцедуры


&НаКлиенте
Процедура RequestURLOnChange(Item)
	УстановитьПредварительныйURL(УИ_ИдентификаторТекущейСтрокиЗапросов);
КонецПроцедуры

&НаКлиенте
Процедура ЗаголовкиСтрокаПриИзменении(Элемент)
	//ЗаполнитьСтруктуруJSONВДеревеЗапросов();
КонецПроцедуры


&НаКлиенте
Процедура RequestsTreeAuthenticationTypeOnChange(Элемент)
	ПриИзмененииВидаАутентификацииЗапроса();
КонецПроцедуры


#EndRegion

#Область ОбработчикиСобытийЭлементовТаблицыФормыДеревоЗапросов

&НаКлиенте
Процедура ДеревоЗапросовПриАктивизацииСтроки(Элемент)
	ПодключитьОбработчикОжидания("ОбработчикОжиданияАктивизацииСтрокиДереваЗапросов", 0.1, True);
КонецПроцедуры


&НаКлиенте
Процедура ДеревоЗапросовПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	Если Не НоваяСтрока Then
		Return;
	EndIf;
	Если Копирование Then
		Return;
	EndIf;
	
	ТекДанные = Элементы.RequestsTree.ТекущиеДанные;
	Если ТекДанные = Неопределено Then
		Return;
	EndIf;
	
	ИнициализироватьСтрокуДереваЗапросов(ТекДанные, ЭтотОбъект);
КонецПроцедуры

&НаКлиенте
Процедура ДеревоЗапросовПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	Если ОтменаРедактирования Then
		Return;
	EndIf;	
	
	ТекДанные = Элементы.RequestsTree.ТекущиеДанные;
	Если ТекДанные = Неопределено Then
		Return;
	EndIf;
	
	Если Не ValueIsFilled(ТекДанные.Name) Then
		Отказ = True;
	EndIf;

КонецПроцедуры


#EndRegion

#Область ОбработчикиСобытийЭлементовТаблицыФормыТаблицаЗаголовковЗапроса


&НаКлиенте
Procedure RequestHeadersTableOnStartEdit(Item, NewRow, Clone)
	Если Не НоваяСтрока Then
		Return;
	EndIf;
	Если Копирование Then
		Return;
	EndIf;
	
	ТекДанные = Элементы.RequestHeadersTable.ТекущиеДанные;
	Если ТекДанные = Неопределено Then
		Return;
	EndIf;
	
	ТекДанные.Использование = True;
КонецПроцедуры

&НаКлиенте
Процедура RequestHeadersTableOnChange(Элемент)
	//ЗаполнитьСтруктуруJSONВДеревеЗапросов();
КонецПроцедуры

&НаКлиенте
Procedure TableRequestHeadersTableKeyAutoComplete(Item, Text, ChoiceData, DataGetParameters, Waiting, 
	StandardProcessing)

	СтандартнаяОбработка = Ложь;

	Если Не ValueIsFilled(Текст) Then
		Return;
	EndIf;

	ДанныеВыбора = Новый СписокЗначений;

	Для Каждого ЭлементСписка Из СписокИспользованныхЗаголовков Цикл
		Если СтрНайти(НРег(ЭлементСписка.Value), НРег(Текст)) > 0 Then
			ДанныеВыбора.Добавить(ЭлементСписка.Value);
		EndIf;
	EndDo;

КонецПроцедуры

#EndRegion

#Область ОбработчикиСобытийЭлементовТаблицыФормыДеревоЗапросовТелоМультипарт
&НаКлиенте
Процедура MultipartBodyRequestsTreeOnStartEdit(Элемент, НоваяСтрока, Копирование)
	Если Не НоваяСтрока Then
		Return;
	EndIf;
	Если Копирование Then
		Return;
	EndIf;
	
	ТекДанные = Элементы.MultipartBodyRequestsTree.ТекущиеДанные;
	Если ТекДанные = Неопределено Then
		Return;
	EndIf;
	ТекДанные.Использование = True;
	ТекДанные.Вид = MultypartItemsType().Файл;
КонецПроцедуры

&НаКлиенте
Процедура MultipartBodyRequestsTreeValueStartChoice(Item, ChoiceData, StandardProcessing)
	ТекДанные = Элементы.MultipartBodyRequestsTree.ТекущиеДанные;
	Если ТекДанные = Неопределено Then
		Return;
	EndIf;
	
	Виды = MultypartItemsType();
	
	ПараметрыОповещения = Новый Структура;
	ПараметрыОповещения.Вставить("ИдентификаторСтрокиЗапросов", УИ_ИдентификаторТекущейСтрокиЗапросов);
	ПараметрыОповещения.Вставить("ИдентификаторСтрокиТела", ТекДанные.ПолучитьИдентификатор());

	ОписаниеОповещенияОЗавершении = Новый ОписаниеОповещения("ДеревоЗапросовТелоМультипартЗначениеНачалоВыбораЗавершениеВыбора",
		ЭтотОбъект, ПараметрыОповещения);

	Если ТекДанные.Вид = Виды.Файл Then
		ДиалогВыбора = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
		ДиалогВыбора.ПроверятьСуществованиеФайла = True;
		ДиалогВыбора.МножественныйВыбор = Ложь;
		ДиалогВыбора.Показать(Новый ОписаниеОповещения("ДеревоЗапросовТелоМультипартЗначениеНачалоВыбораЗавершениеВыбораФайла",
			ЭтотОбъект, Новый Структура("ОписаниеОЗавершении", ОписаниеОповещенияОЗавершении)));
	Иначе
		УИ_ОбщегоНазначенияКлиент.ОткрытьФормуРедактированияТекста(ТекДанные.Value, ОписаниеОповещенияОЗавершении);
	EndIf;
КонецПроцедуры



#EndRegion

#Область ОбработчикиСобытийЭлементовТаблицыФормыПараметрыURL

&НаКлиенте
Процедура ПараметрыURLПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)

	Если Не НоваяСтрока Then
		Return;
	EndIf;

	Если Копирование Then
		Return;
	EndIf;
	ТекДанные = Элементы.URLParameters.ТекущиеДанные;
	Если ТекДанные = Неопределено Then
		Return;
	EndIf;
	
	ТекДанные.Использование = True;
КонецПроцедуры

&НаКлиенте
Процедура ПараметрыЗапросаПриИзменении(Элемент)
	УстановитьПредварительныйURL(УИ_ИдентификаторТекущейСтрокиЗапросов);
КонецПроцедуры


#EndRegion

#Область ОбработчикиКомандФормы

&НаКлиенте
Процедура RequestTreeMoveToLevelUp(Команда)
	
	Строка = RequestsTree.FindByID(Элементы.RequestsTree.ТекущаяСтрока);
	Родитель = Строка.ПолучитьРодителя();

	Если Родитель <> Неопределено Then
		РодительРодителя = Родитель.ПолучитьРодителя();
		Если РодительРодителя = Неопределено Then
			ИндексВставки = RequestsTree.ПолучитьЭлементы().Индекс(Родитель) + 1;
		Иначе
			ИндексВставки = РодительРодителя.ПолучитьЭлементы().Индекс(Родитель) + 1;
		EndIf;
		
		НоваяСтрока = ПереместитьСтрокуДерева(RequestsTree, Строка, ИндексВставки, РодительРодителя);
		
		Элементы.RequestsTree.ТекущаяСтрока = НоваяСтрока.ПолучитьИдентификатор();
	EndIf;

	Модифицированность = True;
	
КонецПроцедуры

&AtClient
Procedure RequestExecute(Command)
	СохранитьДанныеЗапросаВДеревоЗапросов();
	
	СтрокаЗапроса  = ТекущаяСтрокаЗапросов();
	Если СтрокаЗапроса = Неопределено Then
		Return;
	EndIf;
	
	Если Не ВозможноИсполнениеЗапроса(СтрокаЗапроса) Then
		Return;	
	EndIf;
	
	ДопПараметры = Новый Структура;
	ДопПараметры.Вставить("СтрокаЗапроса", СтрокаЗапроса);
	Если СохранятьПередВыполнением И ValueIsFilled(RequestsFileName) Then
		ВыполнитьСохранениеЗапросовВФайл( , Новый ОписаниеОповещения("ВыполнитьЗапросЗавершениеСохраненияФайла",
			ЭтотОбъект, ДопПараметры));
	Иначе
		ВыполнитьЗапросЗавершениеСохраненияФайла(True, ДопПараметры);
	EndIf;
EndProcedure

&НаКлиенте
Процедура FillBodyBinaryDataFromFile(Команда)
	Если УИ_ИдентификаторТекущейСтрокиЗапросов = Неопределено Then
		Return;
	EndIf;
	
	ПараметрыОповещения = Новый Структура();
	ПараметрыОповещения.Вставить("ИдентификаторТекущейСтроки", УИ_ИдентификаторТекущейСтрокиЗапросов);
	
	НачатьПомещениеФайла(Новый ОписаниеОповещения("ЗаполнитьДвоичныеДанныеТелаИзФайлаЗавершение", ЭтотОбъект,
		ПараметрыОповещения), , "", True, УникальныйИдентификатор);
КонецПроцедуры

&НаКлиенте
Процедура SaveBodyRequestBinaryDataFromHistory(Команда)
	ТекДанныеИсторииЗапроса = Элементы.ИсторияЗапросов.ТекущиеДанные;
	Если ТекДанныеИсторииЗапроса = Неопределено Then
		Return;
	EndIf;

	Если Не ЭтоАдресВременногоХранилища(ТекДанныеИсторииЗапроса.ТелоЗапросаАдресДвоичныхДанных) Then
		Return;
	EndIf;

	ДВФ = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);
	ДВФ.МножественныйВыбор = Ложь;

	ПараметрыСохранения = УИ_ОбщегоНазначенияКлиент.НовыйПараметрыСохраненияФайла();
	ПараметрыСохранения.ДиалогВыбораФайла = ДВФ;
	ПараметрыСохранения.АдресФайлаВоВременномХранилище = ТекДанныеИсторииЗапроса.ТелоЗапросаАдресДвоичныхДанных;
	УИ_ОбщегоНазначенияКлиент.НачатьСохранениеФайла(ПараметрыСохранения);

КонецПроцедуры

&НаКлиенте
Процедура SaveBinaryDataBodyAnswerInFile(Команда)
	ТекДанныеИсторииЗапроса = Элементы.ИсторияЗапросов.ТекущиеДанные;
	Если ТекДанныеИсторииЗапроса = Неопределено Then
		Return;
	EndIf;

	Если Не ЭтоАдресВременногоХранилища(ТекДанныеИсторииЗапроса.ТелоОтветаАдресДвоичныхДанных) Then
		Return;
	EndIf;

	ДВФ = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);
	ДВФ.МножественныйВыбор = Ложь;

	ПараметрыСохранения = УИ_ОбщегоНазначенияКлиент.НовыйПараметрыСохраненияФайла();
	ПараметрыСохранения.ДиалогВыбораФайла = ДВФ;
	ПараметрыСохранения.АдресФайлаВоВременномХранилище = ТекДанныеИсторииЗапроса.ТелоОтветаАдресДвоичныхДанных;
	УИ_ОбщегоНазначенияКлиент.НачатьСохранениеФайла(ПараметрыСохранения);

КонецПроцедуры

&НаКлиенте
Процедура RecordHistoryRequestDetailedInformation(Команда)
	СтрокаЗапроса = ТекущаяСтрокаЗапросов();
	Если СтрокаЗапроса = Неопределено Then
		Return;
	EndIf;
	
	ТекДанные = Элементы.RequestsTreeRequestsHistory.ТекущиеДанные;
	Если ТекДанные = Неопределено Then
		Return;
	EndIf;
	
	ПараметрыФормы = Новый Структура;
	ПараметрыФормы.Вставить("СтрокаЗапроса", СтрокаЗапроса.ПолучитьИдентификатор());
	ПараметрыФормы.Вставить("СтрокаИстории", ТекДанные.ПолучитьИдентификатор());

	ОткрытьФорму("Обработка.УИ_КонсольHTTPЗапросов.Форма.ФормаПодробнойИнформацииОЗапросе",
				 ПараметрыФормы,
				 ЭтотОбъект,
				 ""
				 + УникальныйИдентификатор
				 + СтрокаЗапроса.ПолучитьИдентификатор()
				 + ТекДанные.ПолучитьИдентификатор());
КонецПроцедуры


&НаКлиенте
Процедура SaveBodyResponseBinaryData(Команда)
	Если Не ЭтоАдресВременногоХранилища(ТелоОтветаАдресДвоичныхДанных) Then
		Return;
	EndIf;

	ДВФ = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);
	ДВФ.МножественныйВыбор = Ложь;

	ПараметрыСохранения = УИ_ОбщегоНазначенияКлиент.НовыйПараметрыСохраненияФайла();
	ПараметрыСохранения.ДиалогВыбораФайла = ДВФ;
	ПараметрыСохранения.АдресФайлаВоВременномХранилище = ТелоОтветаАдресДвоичныхДанных;
	УИ_ОбщегоНазначенияКлиент.НачатьСохранениеФайла(ПараметрыСохранения);
КонецПроцедуры

&НаКлиенте
Процедура NewRequestFile(Команда)
	Если RequestsTree.ПолучитьЭлементы().Count() = 0 Then
		ИнициализироватьКонсоль();
	Иначе
		ПоказатьВопрос(Новый ОписаниеОповещения("НовыйФайлЗапросовЗавершение", ЭтотОбъект),
			"Дерево запросов непустое. Continue?", РежимДиалогаВопрос.ДаНет, 15, КодВозвратаДиалога.Нет);
	EndIf;
КонецПроцедуры

&НаКлиенте
Процедура OpenRequestFile(Команда)
	Если RequestsTree.ПолучитьЭлементы().Count() = 0 Then
		ЗагрузитьФайлКонсоли();
	Иначе
		ПоказатьВопрос(Новый ОписаниеОповещения("ОткрытьФайлОтчетовЗавершение", ЭтотОбъект),
			"Дерево запросов непустое. Continue?", РежимДиалогаВопрос.ДаНет, 15, КодВозвратаДиалога.Нет);
	EndIf;
КонецПроцедуры

&НаКлиенте
Процедура SaveRequestsToFile(Команда)
	ВыполнитьСохранениеЗапросовВФайл();
КонецПроцедуры

&НаКлиенте
Процедура SaveRequestsToFileAs(Команда)
	ВыполнитьСохранениеЗапросовВФайл(True);
КонецПроцедуры

&НаКлиенте
Процедура EditRequestBodyInJSONEditor(Команда)
	СтрокаДерева = ТекущаяСтрокаЗапросов();
	Если СтрокаДерева = Неопределено Then
		Return;
	EndIf;
	
	ПараметрыОповещения = Новый Структура;
	ПараметрыОповещения.Вставить("ТекущаяСтрока", СтрокаДерева.ПолучитьИдентификатор());

	УИ_ОбщегоНазначенияКлиент.РедактироватьJSON(СтрокаДерева.ТелоСтрокой,
												Ложь,
												Новый ОписаниеОповещения("РедактироватьТелоЗапросаВРедактореJSONЗавершение",
		ЭтотОбъект, ПараметрыОповещения));
КонецПроцедуры

&НаКлиенте
Процедура EditRequestBodyInJSONEditorAnalyzedRequest(Команда)
	УИ_ОбщегоНазначенияКлиент.РедактироватьJSON(Элементы.ИсторияЗапросов.ТекущиеДанные.ТелоЗапросаСтрока, True);
КонецПроцедуры

&НаКлиенте
Процедура EditResponseBodyInJSONEditorAnalyzedRequest(Команда)
	УИ_ОбщегоНазначенияКлиент.РедактироватьJSON(ResponseBodyString, True);
КонецПроцедуры

&НаКлиенте
Процедура CopyRowDataHistoryToRequest(Команда)
	СтрокаЗапроса = ТекущаяСтрокаЗапросов();
	Если СтрокаЗапроса = Неопределено Then
		Return;
	EndIf;
	
	СтрокаИстории = Элементы.RequestsTreeRequestsHistory.ТекущиеДанные;
	Если СтрокаЗапроса = Неопределено Then
		Return;
	EndIf;
	СкопироватьДанныеСтрокиИсторииВЗапросНаСервере(СтрокаЗапроса.ПолучитьИдентификатор(),
												   СтрокаИстории.ПолучитьИдентификатор());
	ИзвлечьДанныеЗапросаИзСтрокиДерева();
КонецПроцедуры

&AtClient
Procedure GenerateExecutionCode(Command)
	ТекДанные = Элементы.RequestsTree.ТекущиеДанные;
	Если ТекДанные = Неопределено Then
		Return;
	EndIf;
	СохранитьДанныеЗапросаВДеревоЗапросов();

	СгенерированныйКод = GeneratedExecutionCodeAtServer(ТекДанные.ПолучитьИдентификатор());

	УИ_ОбщегоНазначенияКлиент.ОткрытьСтрокуКодаВСпециальнойФорме(СгенерированныйКод, "HTTP запрос: " + ТекДанные.Name, ""
																													  + УникальныйИдентификатор
																													  + ТекДанные.ПолучитьИдентификатор());
EndProcedure

//@skip-warning
&НаКлиенте
Процедура Подключаемый_ВыполнитьОбщуюКомандуИнструментов(Команда) 
	УИ_ОбщегоНазначенияКлиент.Подключаемый_ВыполнитьОбщуюКомандуИнструментов(ЭтотОбъект, Команда);
КонецПроцедуры

#EndRegion

#Область СлужебныеПроцедурыИФункции

&НаКлиенте
Процедура ВыполнитьЗапросЗавершениеСохраненияФайла(Результат, ДополнительныеПараметры) Экспорт
	Если Результат <> True Then
		Return;
	EndIf;
	СтрокаЗапроса = ДополнительныеПараметры.СтрокаЗапроса;
	
	ПараметрыСледующегоШага = Новый Структура;
	ПараметрыСледующегоШага.Вставить("RowID", СтрокаЗапроса.ПолучитьИдентификатор());
	ПараметрыСледующегоШага.Вставить("Файл", Неопределено);
	ПараметрыСледующегоШага.Вставить("НаКлиенте", СтрокаЗапроса.НаКлиенте);
	
	Если СтрокаЗапроса.BodyType = TypesOfRequestBody.Файл Then
		Если СтрокаЗапроса.НаКлиенте Then
			ПараметрыСледующегоШага.Файл = Новый Структура;
			ПараметрыСледующегоШага.Файл.Вставить("ПолноеИмя", СтрокаЗапроса.ИмяФайлаТела);
			ВыполнитьЗапросЗавершениеПодготовительныхДействий(ПараметрыСледующегоШага);
		Иначе
			ПараметрыЧтенияФайла = УИ_ОбщегоНазначенияКлиент.НовыйПараметрыЧтенияФайла(УникальныйИдентификатор);
			ПараметрыЧтенияФайла.ПолноеИмяФайла = СтрокаЗапроса.ИмяФайлаТела;
			ПараметрыЧтенияФайла.ОповещениеОЗавершении = Новый ОписаниеОповещения("ВыполнитьЗапросЗавершениеЧтенияФайлаВоВременноеХранилище",
				ЭтотОбъект, ПараметрыСледующегоШага);

			УИ_ОбщегоНазначенияКлиент.НачатьЧтениеФайла(ПараметрыЧтенияФайла);
		EndIf;
	ElsIf СтрокаЗапроса.BodyType = TypesOfRequestBody.МультипартФорм Then
		НачатьПомещениеФайловВоВременноеХранилищеДляСтрокТелаМультипарт(СтрокаЗапроса,
																		Новый ОписаниеОповещения("ВыполнитьЗапросЗавершениеЧтенияФайловМультипартВоВременноеХранилище",
			ЭтотОбъект, ПараметрыСледующегоШага));
	Иначе
		ВыполнитьЗапросЗавершениеПодготовительныхДействий(ПараметрыСледующегоШага);
	EndIf;
	
КонецПроцедуры

&НаКлиенте
Процедура НачатьПомещениеФайловВоВременноеХранилищеДляСтрокТелаМультипарт(СтрокаЗапроса, ОписаниеОповещенияОЗавершении)
	ПараметрыОповещений = Новый Структура;
	ПараметрыОповещений.Вставить("ОписаниеОповещенияОЗавершении", ОписаниеОповещенияОЗавершении);
	ПараметрыОповещений.Вставить("RequestsTreeRow", СтрокаЗапроса);
	ПараметрыОповещений.Вставить("ИндексСтрокиМультипарт", 0);
	ПараметрыОповещений.Вставить("СоответствиеПомещенныхФайлов", Новый Соответствие);

	УИ_ОбщегоНазначенияКлиент.ПодключитьРасширениеРаботыСФайламиСВозможнойУстановкой(Новый ОписаниеОповещения("НачатьПомещениеФайловВоВременноеХранилищеДляСтрокТелаМультипартЗавершениеПодключенияРасширенияРаботыСФайлам",
		ЭтотОбъект, ПараметрыОповещений));
КонецПроцедуры


// Начать помещение файлов во временное хранилище для строк тела мультипарт завершение подключения расширения работы с файлам.
// 
// Параметры:
//  Подключено - Булево- Подключено
//  ДополнительныеПараметры - Структура:
//  * ОписаниеОповещенияОЗавершении - ОписаниеОповещения
//  * RequestsTreeRow - ДанныеФормыЭлементДерева
&НаКлиенте
Процедура НачатьПомещениеФайловВоВременноеХранилищеДляСтрокТелаМультипартЗавершениеПодключенияРасширенияРаботыСФайлам(Подключено,
	ДополнительныеПараметры) Экспорт
	Если Не Подключено Then
		Return;
	EndIf;
	
	ПоместитьОчереднойФайлМультипарт(ДополнительныеПараметры);
КонецПроцедуры

// Поместить очередной файл мультипарт.
// 
// Параметры:
//  ДополнительныеПараметры - Структура:
//  * ОписаниеОповещенияОЗавершении - ОписаниеОповещения
//  * RequestsTreeRow - ДанныеФормыЭлементДерева
//  * СоответствиеПомещенныхФайлов - Соответствие из КлючИЗначение
//  * ИндексСтрокиМультипарт - Число
&НаКлиенте
Процедура ПоместитьОчереднойФайлМультипарт(ДополнительныеПараметры)
	ВидыМультипарт = MultypartItemsType();
	
	Для ТекИндекс = ДополнительныеПараметры.ИндексСтрокиМультипарт По ДополнительныеПараметры.RequestsTreeRow.MultipartBody.Count()
																	  - 1 Цикл
		MultypartItemRow = ДополнительныеПараметры.RequestsTreeRow.MultipartBody[ТекИндекс];
		Если MultypartItemRow.Type <> ВидыМультипарт.Файл Then
			Continue;
		EndIf;
		Если Не ValueIsFilled(MultypartItemRow.Value) Then
			Continue;
		EndIf;

		ДополнительныеПараметры.ИндексСтрокиМультипарт = ТекИндекс;

		ПараметрыЧтения = УИ_ОбщегоНазначенияКлиент.НовыйПараметрыЧтенияФайла(УникальныйИдентификатор);
		ПараметрыЧтения.РасширениеРаботыСФайламиПодключено = True;
		ПараметрыЧтения.ПолноеИмяФайла = MultypartItemRow.Value;
		ПараметрыЧтения.ОповещениеОЗавершении = Новый ОписаниеОповещения("ПоместитьОчереднойФайлМультипартЗавершениеЧтенияОчередногоФайла",
			ЭтотОбъект, ДополнительныеПараметры);

		УИ_ОбщегоНазначенияКлиент.НачатьЧтениеФайла(ПараметрыЧтения);
		Return;
	EndDo;

	ВыполнитьОбработкуОповещения(ДополнительныеПараметры.ОписаниеОповещенияОЗавершении,
								 ДополнительныеПараметры.СоответствиеПомещенныхФайлов);
КонецПроцедуры

// Поместить очередной файл мультипарт завершение чтения очередного файла.
// 
// Параметры:
//  Результат - Массив Из Структура:
//  	* ПолноеИмя - Строка
//  	* Хранение - Строка
//  ДополнительныеПараметры - Структура:
//  	* ОписаниеОповещенияОЗавершении - ОписаниеОповещения
//  	* RequestsTreeRow - ДанныеФормыЭлементДерева
//  	* СоответствиеПомещенныхФайлов - Соответствие из КлючИЗначение
//  	* ИндексСтрокиМультипарт - Число
&НаКлиенте
Процедура ПоместитьОчереднойФайлМультипартЗавершениеЧтенияОчередногоФайла(Результат, ДополнительныеПараметры) Экспорт
	Если Результат <> Неопределено Then
		Если Результат.Count() > 0 Then
			ДополнительныеПараметры.СоответствиеПомещенныхФайлов.Вставить(ДополнительныеПараметры.ИндексСтрокиМультипарт,
																		  Результат[0].Хранение);
		EndIf;
	EndIf;
	ДополнительныеПараметры.ИндексСтрокиМультипарт = ДополнительныеПараметры.ИндексСтрокиМультипарт + 1;
	ПоместитьОчереднойФайлМультипарт(ДополнительныеПараметры);
КонецПроцедуры


&НаКлиенте
Процедура ДеревоЗапросовТелоМультипартЗначениеНачалоВыбораЗавершениеВыбораФайла(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт
	Если ВыбранныеФайлы = Неопределено Then
		Return;
	EndIf;
	Если ВыбранныеФайлы.Count() = 0  Then
		Return;
	EndIf;
	
	ВыполнитьОбработкуОповещения(ДополнительныеПараметры.ОписаниеОЗавершении, ВыбранныеФайлы[0]);
КонецПроцедуры

// Дерево запросов тело мультипарт значение начало выбора завершение выбора.
// 
// Параметры:
//  Результат - Строка, Неопределено - Результат
//  ДополнительныеПараметры - Структура:
//  * ИдентификаторСтрокиЗапросов - Число
//  * ИдентификаторСтрокиТела - Число
&НаКлиенте
Процедура ДеревоЗапросовТелоМультипартЗначениеНачалоВыбораЗавершениеВыбора(Результат, ДополнительныеПараметры) Экспорт
	Если Результат = Неопределено Then
		Return;
	EndIf;
	
	СтрокаДерева = RequestsTree.FindByID(ДополнительныеПараметры.ИдентификаторСтрокиЗапросов);
	Если СтрокаДерева = Неопределено Then
		Return;
	EndIf;
	
	СтрокаТела = СтрокаДерева.MultipartBody.FindByID(ДополнительныеПараметры.ИдентификаторСтрокиТела);
	Если СтрокаТела = Неопределено Then
		Return;
	EndIf;
	
	СтрокаТела.Value = Результат;
	Модифицированность = True;
КонецПроцедуры

&НаКлиенте
Процедура ОбработчикОжиданияАктивизацииСтрокиДереваЗапросов()
	СохранитьДанныеЗапросаВДеревоЗапросов();
	
	ТекДанные = Элементы.RequestsTree.ТекущиеДанные;
	Если ТекДанные = Неопределено Then
		Return;
	EndIf;

	УИ_ИдентификаторТекущейСтрокиЗапросов = ТекДанные.ПолучитьИдентификатор();
	ИзвлечьДанныеЗапросаИзСтрокиДерева();
	
КонецПроцедуры

&НаКлиенте
Процедура УстановитьЗаголовкиПоСодержимомуТелаЗапроса()
	СтрокаДерева = ТекущаяСтрокаЗапросов();
	Если СтрокаДерева = Неопределено Then
		Return;
	EndIf;
	
	ЗначениеЗаголовкаСодержимого = "";

	Если СтрокаДерева.BodyType = TypesOfRequestBody.Строка Then
		Если СтрокаДерева.ТипСтроковогоСодержимого <> "Нет" И ValueIsFilled(СтрокаДерева.ТипСтроковогоСодержимого) Then
			ТипыТекстов = ТипыТекстовогоСодержимого();
			Если ТипыТекстов.Свойство(СтрокаДерева.ТипСтроковогоСодержимого) Then
				ЗначениеЗаголовкаСодержимого = ТипыТекстов[СтрокаДерева.ТипСтроковогоСодержимого];

				Кодировка = "";
				
				Кодировки = ВидыКодировокТелаЗапроса();
								
				Если СтрокаДерева.КодировкаТела = Кодировки.Auto
					Или СтрокаДерева.КодировкаТела = Кодировки.Системная Then
						
				ElsIf СтрокаДерева.КодировкаТела = Кодировки.UTF8 Then 
					Кодировка="utf-8";
				ElsIf СтрокаДерева.КодировкаТела = Кодировки.ANSI Then 
					Кодировка = "windows-1251";
				ElsIf СтрокаДерева.КодировкаТела = Кодировки.UTF16 Then 
					Кодировка = "utf-16";
				ElsIf СтрокаДерева.КодировкаТела = Кодировки.OEM Then 
					Кодировка = "cp866";
				ElsIf ValueIsFilled(СтрокаДерева.КодировкаТела) Then
					Кодировка = СтрокаДерева.КодировкаТела;
				EndIf;
				Если ValueIsFilled(Кодировка) Then
					ЗначениеЗаголовкаСодержимого = ЗначениеЗаголовкаСодержимого
												   + "; charset="
												   + Кодировка;
				EndIf;
			EndIf;
		EndIf;
	ElsIf СтрокаДерева.BodyType = TypesOfRequestBody.ДвоичныеДанные Then 
		//ЗначениеЗаголовкаСодержимого = "application/octet-stream";	
	ElsIf СтрокаДерева.BodyType = TypesOfRequestBody.МультипартФорм Then
		ЗначениеЗаголовкаСодержимого = "multipart/form-data; boundary=" + MultipartBodySplitter;
	Иначе
		Return;
	EndIf;
		
	ИмяЗаголовкаПоиска = "Content-Type";
	
	Если ValueIsFilled(ЗначениеЗаголовкаСодержимого) Then
		ДобавитьЗаголовокЗапроса(ИмяЗаголовкаПоиска, ЗначениеЗаголовкаСодержимого);
//	Иначе
//		УдалитьЗаголовокЗапроса(ИмяЗаголовкаПоиска);
	EndIf;

КонецПроцедуры

&НаКлиенте
Процедура ДобавитьЗаголовокЗапроса(ИмяЗаголовка, ЗначениеЗаголовка)
	Если РедактированиеЗаголовковТаблицей Then
		НайденаСтрокаЗаголовка = Ложь;
		Для Каждого Стр Из RequestHeadersTable Цикл
			Если НРег(ИмяЗаголовка) = НРег(Стр.Ключ) Then
				Стр.Использование = True;
				Стр.Value = ЗначениеЗаголовка;
				
				НайденаСтрокаЗаголовка = True;
				Прервать;
			EndIf;
		EndDo;
		
		Если Не НайденаСтрокаЗаголовка Then
			Стр = RequestHeadersTable.Добавить();
			Стр.Использование = True;
			Стр.Ключ = ИмяЗаголовка;
			Стр.Value = ЗначениеЗаголовка;	
		EndIf;
	Иначе
		СтрокиЗаголовков = СтрРазделить(ЗаголовкиСтрока, Chars.LF);
		
		ИскомыйИндексЗаголовка = Неопределено;
		
		Для Индекс = 0 по СтрокиЗаголовков.Count() -1 Цикл
			Стр = СтрокиЗаголовков[Индекс];
			
			Если Не ValueIsFilled(Стр) Then
				Continue;
			EndIf;
			
			МассивЗаголовка = СтрРазделить(Стр, ":");
			Если НРег(МассивЗаголовка[0]) = НРег(ИмяЗаголовка) Then
				ИскомыйИндексЗаголовка = Индекс;
				Прервать;
			EndIf;
		EndDo;
		
		СторокаДляВставки = StrTemplate("%1:%2",ИмяЗаголовка, ЗначениеЗаголовка);
		
		Если ИскомыйИндексЗаголовка = Неопределено Then
			СтрокиЗаголовков.Добавить(СторокаДляВставки);
		Иначе
			СтрокиЗаголовков[ИскомыйИндексЗаголовка] = СторокаДляВставки;
		EndIf;
			
		ЗаголовкиСтрока = StrConcat(СтрокиЗаголовков, Chars.LF);
		
	EndIf;
КонецПроцедуры

&НаКлиенте 
Процедура УдалитьЗаголовокЗапроса(ИмяЗаголовка)
	Если РедактированиеЗаголовковТаблицей Then
		УдаляемаяСтрока = Неопределено;
		Для Каждого Стр Из RequestHeadersTable Цикл
			Если НРег(ИмяЗаголовка) = НРег(Стр.Ключ) Then
				УдаляемаяСтрока = Стр;
				Прервать;
			EndIf;
		EndDo;
		
		Если УдаляемаяСтрока <> Неопределено Then
			RequestHeadersTable.Удалить(УдаляемаяСтрока);
		EndIf;
	Иначе
		СтрокиЗаголовков = СтрРазделить(ЗаголовкиСтрока, Chars.LF);
		
		ИскомыйИндексЗаголовка = Неопределено;
		
		Для Индекс = 0 по СтрокиЗаголовков.Count() -1 Цикл
			Стр = СтрокиЗаголовков[Индекс];
			
			Если Не ValueIsFilled(Стр) Then
				Continue;
			EndIf;
			
			МассивЗаголовка = СтрРазделить(Стр, ":");
			Если НРег(МассивЗаголовка[0]) = НРег(ИмяЗаголовка) Then
				ИскомыйИндексЗаголовка = Индекс;
				Прервать;
			EndIf;
		EndDo;

		Если ИскомыйИндексЗаголовка <> Неопределено Then
			СтрокиЗаголовков.Удалить(ИскомыйИндексЗаголовка);
			ЗаголовкиСтрока = StrConcat(СтрокиЗаголовков, Chars.LF);
		EndIf;
		
	EndIf;	
КонецПроцедуры

&НаКлиенте
Function ПереместитьСтрокуДерева(Дерево, ПеремещаемаяСтрока, ИндексВставки, НовыйРодитель, Уровень = 0)

	Если Уровень = 0 Then

		Если НовыйРодитель = Неопределено Then
			НоваяСтрока = Дерево.ПолучитьЭлементы().Вставить(ИндексВставки);
		Иначе
			НоваяСтрока = НовыйРодитель.ПолучитьЭлементы().Вставить(ИндексВставки);
		EndIf;

		ЗаполнитьЗначенияСвойств(НоваяСтрока, ПеремещаемаяСтрока);
		ПереместитьСтрокуДерева(Дерево, ПеремещаемаяСтрока, ИндексВставки, НоваяСтрока, Уровень + 1);

		ПеремещаемаяСтрокаРодитель = ПеремещаемаяСтрока.ПолучитьРодителя();
		Если ПеремещаемаяСтрокаРодитель = Неопределено Then
			Дерево.ПолучитьЭлементы().Удалить(ПеремещаемаяСтрока);
		Иначе
			ПеремещаемаяСтрокаРодитель.ПолучитьЭлементы().Удалить(ПеремещаемаяСтрока);
		EndIf;

	Иначе

		Для Каждого Строка Из ПеремещаемаяСтрока.ПолучитьЭлементы() Цикл
			НоваяСтрока = НовыйРодитель.ПолучитьЭлементы().Добавить();
			
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ПеремещаемаяСтрока);
			
			ПереместитьСтрокуДерева(Дерево, Строка, НоваяСтрока, ИндексВставки, Уровень + 1);
		EndDo;

	EndIf;

	Return НоваяСтрока;

EndFunction




&AtServer
Процедура СкопироватьДанныеСтрокиИсторииВЗапросНаСервере(ИдентификаторСтрокиЗапросов, ИдентификаторСтрокиИстории)
	СтрокаЗапроса = RequestsTree.FindByID(ИдентификаторСтрокиЗапросов);
	СтрокаИстории = СтрокаЗапроса.ИсторияЗапросов.FindByID(ИдентификаторСтрокиИстории);
	
	СтрокаЗапроса.RequestURL = СтрокаИстории.RequestURL;
	СтрокаЗапроса.BodyType = СтрокаИстории.RequestBodyType;
	СтрокаЗапроса.HTTPRequest = СтрокаИстории.HTTPFunction;
	СтрокаЗапроса.ИмяФайлаТела = СтрокаИстории.ТелоЗапросаИмяФайла;
	СтрокаЗапроса.UseBOM = СтрокаИстории.BOM;
	СтрокаЗапроса.UseProxy = СтрокаИстории.UseProxy;
	СтрокаЗапроса.КодировкаТела = СтрокаИстории.RequestBodyEncoding;
	СтрокаЗапроса.ProxyOSAuthentication = СтрокаИстории.ProxyOSAuthentication;
	СтрокаЗапроса.ProxyPassword = СтрокаИстории.ProxyPassword;
	СтрокаЗапроса.ProxyPort = СтрокаИстории.ProxyPort;
	СтрокаЗапроса.ProxyUser = СтрокаИстории.ProxyUser;
	СтрокаЗапроса.ProxyServer = СтрокаИстории.ProxyServer;
	СтрокаЗапроса.Timeout = СтрокаИстории.Timeout;
	СтрокаЗапроса.ТелоСтрокой = СтрокаИстории.ТелоЗапросаСтрока;

	СтрокаЗапроса.ТелоДвоичныеДанные = Неопределено;
	Если ЭтоАдресВременногоХранилища(СтрокаИстории.ТелоЗапросаАдресДвоичныхДанных) Then
		ДвоичныеДанные = ПолучитьИзВременногоХранилища(СтрокаИстории.ТелоЗапросаАдресДвоичныхДанных);
		Если ТипЗнч(ДвоичныеДанные) = Тип("ДвоичныеДанные") Then
			СтрокаЗапроса.ТелоДвоичныеДанные = УИ_ОбщегоНазначения.ЗначениеХранилищаКонтейнераДвочныхДанных(ДвоичныеДанные);
		EndIf;
	EndIf;
	
	ЗаполнитьТаблицуЗаголовковПоСтроке(СтрокаИстории.ЗаголовкиЗапроса, СтрокаЗапроса.Заголовки);
//	СтрокаЗапроса.URLParameters = СтрокаИстории.RequestBodyEncoding;

КонецПроцедуры

&НаКлиенте
Function СтруктураОписанияСохраняемогоФайла()
	Структура=УИ_ОбщегоНазначенияКлиент.ПустаяСтруктураОписанияВыбираемогоФайла();
	Структура.ИмяФайла=RequestsFileName;

	// Пока закоментим сохранение в JSON, т.к. библиотека ошибки выдает на двоичных данных
	УИ_ОбщегоНазначенияКлиент.ДобавитьФорматВОписаниеФайлаСохранения(Структура,
		"Файл запросов консоли HTTP (*.uihttp)", "uihttp");

	Return Структура;
EndFunction

&НаКлиенте
Процедура ВыполнитьСохранениеЗапросовВФайл(СохранитьКак = Ложь, ОписаниеОповещенияОЗаверешении = Неопределено)
	СохранитьДанныеЗапросаВДеревоЗапросов();
	
	ДопПараметрыОповещения = Неопределено;
	Если ОписаниеОповещенияОЗаверешении <> Неопределено Then
		ДопПараметрыОповещения = Новый Структура;
		ДопПараметрыОповещения.Вставить("ОписаниеОповещенияОЗаверешении", ОписаниеОповещенияОЗаверешении);
	EndIf;

	УИ_ОбщегоНазначенияКлиент.СохранитьДанныеКонсолиВФайл("КонсольHTTPЗапросов",
														  СохранитьКак,
														  СтруктураОписанияСохраняемогоФайла(),
														  ПолучитьСтрокуДанныхФайлаДляСохраненияВФайл(),
														  Новый ОписаниеОповещения("СохранениеВФайлЗавершение",
		ЭтотОбъект, ДопПараметрыОповещения));

КонецПроцедуры

&НаКлиенте
Процедура ПриИзмененииВидаТелаЗапроса()
	СтрокаЗапроса = ТекущаяСтрокаЗапросов();	
	Если СтрокаЗапроса = Неопределено Then
		Return;
	EndIf;
		
	Если СтрокаЗапроса.BodyType = TypesOfRequestBody.БезТела Then
		НоваяСтраница = Элементы.RequestBodyBodylessPageGroup;
	ElsIf СтрокаЗапроса.BodyType = TypesOfRequestBody.Строка Then
		НоваяСтраница = Элементы.RequestBodyStringPageGroup;
	ElsIf СтрокаЗапроса.BodyType = TypesOfRequestBody.ДвоичныеДанные Then
		НоваяСтраница = Элементы.BinaryDataRequestBodyPageGroup;
	ElsIf СтрокаЗапроса.BodyType = TypesOfRequestBody.МультипартФорм Then 
		НоваяСтраница = Элементы.BodyMultypartPageGroup;
	Иначе
		НоваяСтраница = Элементы.BadyFileNameRequestBodySPageGroup;
	EndIf;

	Элементы.RequestBodyPageGroup.ТекущаяСтраница = НоваяСтраница;
	
	УстановитьЗаголовкиПоСодержимомуТелаЗапроса();
КонецПроцедуры


&НаКлиенте
Процедура ПриИзмененииВидаАутентификацииЗапроса()
	СтрокаЗапроса = ТекущаяСтрокаЗапросов();	
	Если СтрокаЗапроса = Неопределено Then
		Return;
	EndIf;
		
	Виды = ВидыАутентификации();
		
	ВидимостьГруппыНастроекАутентификации = True;	
	Если СтрокаЗапроса.АутентификацияВид = Виды.Базовая Then
		НоваяСтраница = Элементы.ГруппаСтраницаАутентифкацияБазовая;
	ElsIf СтрокаЗапроса.АутентификацияВид = Виды.BearerToken Then
		НоваяСтраница = Элементы.TokenAuthenticationPageGroup;
	ElsIf СтрокаЗапроса.АутентификацияВид = Виды.NTML Then 
		НоваяСтраница = Элементы.StubAuthenticationPageGroup;
	Иначе
		ВидимостьГруппыНастроекАутентификации = Ложь;
		НоваяСтраница = Элементы.StubAuthenticationPageGroup;
	EndIf;

	Элементы.AuthenticationTypePageGroup.ТекущаяСтраница = НоваяСтраница;
	Элементы.RequestsAuthenticationSettingsGroup.Видимость = ВидимостьГруппыНастроекАутентификации;
КонецПроцедуры

&НаКлиенте
Function ТекущаяСтрокаЗапросов()
	Если УИ_ИдентификаторТекущейСтрокиЗапросов = Неопределено Then
		Return Неопределено;
	EndIf;
	Return RequestsTree.FindByID(УИ_ИдентификаторТекущейСтрокиЗапросов);	
	
EndFunction

// Виды тела запроса.
// 
// Возвращаемое значение:
//  Структура -  Виды тела запроса:
// * Строка - Строка - 
// * ДвоичныеДанные - Строка - 
// * Файл - Строка - 
&НаКлиентеНаСервереБезКонтекста
Function ВидыТелаЗапроса()

	ВидыТела = Новый Структура;
	ВидыТела.Вставить("БезТела", "БезТела");	
	ВидыТела.Вставить("Строка", "Строка");	
	ВидыТела.Вставить("ДвоичныеДанные", "ДвоичныеДанные");	
	ВидыТела.Вставить("Файл", "Файл");	
	ВидыТела.Вставить("МультипартФорм", "МультипартФорм");	

	Return ВидыТела;
EndFunction

// Виды элементов мультипарт.
// 
// Возвращаемое значение:
//  Структура -  Виды элементов мультипарт:
// * Строка - Строка - 
// * Файл - Строка - 
&НаКлиентеНаСервереБезКонтекста
Function MultypartItemsType()
	Виды = Новый Структура;
	Виды.Вставить("Строка", "Строка");
	Виды.Вставить("Файл", "Файл");
	
	Return Виды;
EndFunction

// Виды HTTPМетодов.
// 
// Возвращаемое значение:
//  Структура -  Виды HTTPМетодов:
// * GET - Строка - 
// * POST - Строка - 
// * PUT - Строка - 
// * PATCH - Строка - 
// * DELETE - Строка - 
// * OPTIONS - Строка - 
// * HEAD - Строка - 
&НаКлиентеНаСервереБезКонтекста
Function ВидыHTTPМетодов()
	Виды = Новый Структура;
	Виды.Вставить("GET", "GET");
	Виды.Вставить("POST", "POST");
	Виды.Вставить("PUT", "PUT");
	Виды.Вставить("PATCH", "PATCH");
	Виды.Вставить("DELETE", "DELETE");
	Виды.Вставить("OPTIONS", "OPTIONS");
	Виды.Вставить("HEAD", "HEAD");
	
	Return Виды;
EndFunction

&НаКлиентеНаСервереБезКонтекста
Function ТипыТекстовогоСодержимого()
	Типы = Новый Структура;
	Типы.Вставить("json", "application/json");
	Типы.Вставить("xml", "application/xml");
	Типы.Вставить("yaml", "text/yaml");
	Типы.Вставить("текст", "text/plain");

	Return Типы;	
EndFunction

&НаКлиентеНаСервереБезКонтекста
Function ВидыАутентификации()
	Виды = Новый Структура;
	Виды.Вставить("Нет", "Нет");
	Виды.Вставить("Базовая", "Базовая");
	Виды.Вставить("BearerToken", "BearerToken");
	Виды.Вставить("NTML", "NTML");
	
	Return Виды;
EndFunction

#Область ПараметрыДереваЗапроса



&НаКлиенте
Function ПодготовитьСтрокуПараметров()
//		стрПараметры = "";
//		
//	Для Каждого стрПараметра Из URLParameters Цикл
//		Если стрПараметра.Использование Then
//			Если ПустаяСтрока(стрПараметры) Then
//				стрПараметры = StrTemplate("%1=%2", стрПараметра.Name, стрПараметра.Value);
//			Иначе
//				стрПараметры = стрПараметры+"&"+StrTemplate("%1=%2", стрПараметра.Name, стрПараметра.Value);
//			EndIf;
//		EndIf;
//	EndDo;
//	
//	Return стрПараметры;
Return "";
EndFunction

#EndRegion

#Область ФайлыЗапросов

// Отработка загрузки файла с отчетами из адреса.
&НаКлиенте
Процедура ОтработкаЗагрузкиИзАдреса(Адрес)

	ЗагрузитьФайлКонсолиНаСервере(Адрес);
	ОбновитьЗаголовок();
	
КонецПроцедуры

&AtServer
Процедура ЗаполнитьЗапросыИзФайла(ЗапросФайла, КоллекцияЭлементовЗапросов, ВерсияФормата)
	НоваяСтрокаЗапросов = КоллекцияЭлементовЗапросов.Добавить();
	НоваяСтрокаЗапросов.Name = ЗапросФайла.Name;
	НоваяСтрокаЗапросов.RequestURL = ЗапросФайла.RequestURL;
	НоваяСтрокаЗапросов.BodyType = ЗапросФайла.BodyType;
	НоваяСтрокаЗапросов.HTTPRequest = ЗапросФайла.HTTPRequest;
	НоваяСтрокаЗапросов.ИмяФайлаТела = ЗапросФайла.ИмяФайлаТела;
	НоваяСтрокаЗапросов.UseBOM = ЗапросФайла.UseBOM;
	НоваяСтрокаЗапросов.КодировкаТела = ЗапросФайла.КодировкаТела;
	НоваяСтрокаЗапросов.UseProxy = ЗапросФайла.UseProxy;
	НоваяСтрокаЗапросов.ProxyOSAuthentication = ЗапросФайла.ProxyOSAuthentication;
	НоваяСтрокаЗапросов.ProxyPassword = ЗапросФайла.ProxyPassword;
	НоваяСтрокаЗапросов.ProxyUser = ЗапросФайла.ProxyUser;
	НоваяСтрокаЗапросов.ProxyPort = ЗапросФайла.ProxyPort;
	НоваяСтрокаЗапросов.ProxyServer = ЗапросФайла.ProxyServer;
	НоваяСтрокаЗапросов.Timeout = ЗапросФайла.Timeout;
	НоваяСтрокаЗапросов.ТелоСтрокой = ЗапросФайла.ТелоСтрокой;
	НоваяСтрокаЗапросов.ТелоДвоичныеДанные = Неопределено;
	НоваяСтрокаЗапросов.ТипСтроковогоСодержимого = ЗапросФайла.ТипСтроковогоСодержимого;
	НоваяСтрокаЗапросов.Комментарий = ЗапросФайла.Комментарий;

	Если ВерсияФормата >=3 Then
		НоваяСтрокаЗапросов.НаКлиенте = ЗапросФайла.НаКлиенте;
	EndIf;

	//Аутентификация
	НоваяСтрокаЗапросов.АутентификацияВид = ЗапросФайла.АутентификацияВид;
	НоваяСтрокаЗапросов.АутентификацияИспользовать = ЗапросФайла.АутентификацияИспользовать;
	НоваяСтрокаЗапросов.АутентификацияПароль = ЗапросФайла.АутентификацияПароль;
	НоваяСтрокаЗапросов.АутентификацияПользователь = ЗапросФайла.АутентификацияПользователь;
	НоваяСтрокаЗапросов.АутентификацияИмяЗаголовка = ЗапросФайла.АутентификацияИмяЗаголовка;
	НоваяСтрокаЗапросов.АутентификацияПрефиксТокена = ЗапросФайла.АутентификацияПрефиксТокена;
	

	Если ЗапросФайла.ТелоДвоичныеДанные <> Неопределено Then
		Попытка
			Хранилище = ЗначениеИзСтрокиВнутр(ЗапросФайла.ТелоДвоичныеДанные);//ХранилищеЗначения
			ДвоичныеДанные = Хранилище.Получить();
			НоваяСтрокаЗапросов.ТелоДвоичныеДанные = УИ_ОбщегоНазначения.ЗначениеХранилищаКонтейнераДвочныхДанных(ДвоичныеДанные);
		Исключение
			УИ_ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Для запроса "
																 + НоваяСтрокаЗапросов.Name
																 + " не удалось прочитать двоичные данные тела запроса");
		КонецПопытки;
	EndIf;

	Для Каждого ТекЗаголовок Из ЗапросФайла.Заголовки Цикл
		НоваяСтрока = НоваяСтрокаЗапросов.Заголовки.Добавить();
		НоваяСтрока.Использование = ТекЗаголовок.Использование;
		НоваяСтрока.Ключ = ТекЗаголовок.Ключ;
		НоваяСтрока.Value = ТекЗаголовок.Value;
	EndDo;	
	
	Для Каждого ТекЗаголовок Из ЗапросФайла.URLParameters Цикл
		НоваяСтрока = НоваяСтрокаЗапросов.URLParameters.Добавить();
		НоваяСтрока.Использование = ТекЗаголовок.Использование;
		НоваяСтрока.Name = ТекЗаголовок.Name;
		НоваяСтрока.Value = ТекЗаголовок.Value;
	EndDo;	

	Для Каждого ТекОписание Из ЗапросФайла.MultipartBody Цикл
		НоваяСтрока = НоваяСтрокаЗапросов.MultipartBody.Добавить();
		НоваяСтрока.Использование = ТекОписание.Использование;
		НоваяСтрока.Name = ТекОписание.Name;
		НоваяСтрока.Вид = ТекОписание.Вид;
		НоваяСтрока.Value = ТекОписание.Value;
	EndDo;

	КоллекцияСтрок = НоваяСтрокаЗапросов.ПолучитьЭлементы();
	Для Каждого ПодчиненныйЗапрос Из ЗапросФайла.Строки Цикл
		ЗаполнитьЗапросыИзФайла(ПодчиненныйЗапрос, КоллекцияСтрок, ВерсияФормата)
	EndDo;

КонецПроцедуры



// Загрузить файл консоли на сервере.
//
// Параметры:
//  Адрес - Строка -адрес хранилища, из которого нужно загрузить файл.
&AtServer
Процедура ЗагрузитьФайлКонсолиНаСервере(Адрес)
	
	ДанныеФайла=ПолучитьИзВременногоХранилища(Адрес);

	ЧтениеJSON=Новый ЧтениеJSON;
	ЧтениеJSON.ОткрытьПоток(ДанныеФайла.ОткрытьПотокДляЧтения());

	СтруктураФайла=ПрочитатьJSON(ЧтениеJSON);
	ЧтениеJSON.Закрыть();

	ЭлементыЗапросов =  RequestsTree.ПолучитьЭлементы();
	ЭлементыЗапросов.Очистить();
	
	Для Каждого ТекЗапрос Из СтруктураФайла.Запросы Цикл
		ЗаполнитьЗапросыИзФайла(ТекЗапрос, ЭлементыЗапросов, СтруктураФайла.ВерсияФормата);	
	EndDo;

КонецПроцедуры

&НаКлиенте
Процедура ЗагрузитьФайлКонсолиПослеПомещенияФайла(Результат, ДополнительныеПараметры) Экспорт
	Если Результат = Неопределено Then
		Return;
	EndIf;
	
	УИ_ИдентификаторТекущейСтрокиЗапросов = Неопределено;
	RequestsFileName = Результат.ИмяФайла;
	ОтработкаЗагрузкиИзАдреса(Результат.Адрес);
	
	Модифицированность = Ложь;
КонецПроцедуры

// Загрузить файл.
//
// Параметры:
//  БезВыбораФайла - Булево
&НаКлиенте
Процедура ЗагрузитьФайлКонсоли(БезВыбораФайла = Ложь)

	УИ_ОбщегоНазначенияКлиент.ПрочитатьДанныеКонсолиИзФайла("КонсольHTTPЗапросов",
															СтруктураОписанияСохраняемогоФайла(),
															Новый ОписаниеОповещения("ЗагрузитьФайлКонсолиПослеПомещенияФайла",
		ЭтотОбъект),
															БезВыбораФайла);

КонецПроцедуры

// Завершение обработчика открытия файла.
// 
// Параметры:
//  РезультатВопроса - КодВозвратаДиалога 
//  ДополнительныеПараметры - Произвольный
&НаКлиенте
Процедура ОткрытьФайлОтчетовЗавершение(РезультатВопроса, ДополнительныеПараметры) Экспорт

	Если РезультатВопроса = КодВозвратаДиалога.Нет Then
		Return;
	EndIf;
	ЗагрузитьФайлКонсоли();
	
КонецПроцедуры

&НаКлиенте
Процедура ИнициализироватьКонсоль()
	Модифицированность = Ложь;
	RequestsFileName = "";

	RequestsTree.ПолучитьЭлементы().Очистить();
	ИнициализироватьДеревоЗапросов();

	ОбновитьЗаголовок();
КонецПроцедуры

// Завершение обработчика создания нового файла запросов.
// 
// Параметры:
//  РезультатВопроса - КодВозвратаДиалога
//  ДополнительныеПараметры - Произвольный
&НаКлиенте
Процедура НовыйФайлЗапросовЗавершение(РезультатВопроса, ДополнительныеПараметры) Экспорт

	Если РезультатВопроса = КодВозвратаДиалога.Нет Then
		Return;
	EndIf;

	ИнициализироватьКонсоль();

КонецПроцедуры

// Завершение обработчика открытия файла.
// 
// Параметры:
//  Результат - Строка
//  ДополнительныеПараметры - Произвольный
&НаКлиенте
Процедура СохранениеВФайлЗавершение(Результат, ДополнительныеПараметры) Экспорт
	Если Результат = Неопределено Then
		Return;
	EndIf;

	RequestsFileName=Результат;
	Модифицированность = Ложь;
	ОбновитьЗаголовок();

	Если ДополнительныеПараметры <> Неопределено Then
		ВыполнитьОбработкуОповещения(ДополнительныеПараметры.ОписаниеОповещенияОЗаверешении, True);
	EndIf;
КонецПроцедуры

&AtServer
Function ОписаниеЗапросаДляСохраненияВФайл(RequestsTreeRow)
	ОписаниеЗапроса = Новый Структура;
	ОписаниеЗапроса.Вставить("Имя", RequestsTreeRow.Name);
	ОписаниеЗапроса.Вставить("RequestURL", RequestsTreeRow.RequestURL);
	ОписаниеЗапроса.Вставить("ВидТела", RequestsTreeRow.BodyType);
	ОписаниеЗапроса.Вставить("HTTPRequest", RequestsTreeRow.HTTPRequest);
	ОписаниеЗапроса.Вставить("ИмяФайлаТела", RequestsTreeRow.ИмяФайлаТела);
	ОписаниеЗапроса.Вставить("UseBOM", RequestsTreeRow.ИспользоватьBOM);
	ОписаниеЗапроса.Вставить("КодировкаТела", RequestsTreeRow.КодировкаТела);
	ОписаниеЗапроса.Вставить("UseProxy", RequestsTreeRow.UseProxy);
	ОписаниеЗапроса.Вставить("ProxyOSAuthentication", RequestsTreeRow.ProxyOSAuthentication);
	ОписаниеЗапроса.Вставить("ProxyPassword", RequestsTreeRow.ProxyPassword);
	ОписаниеЗапроса.Вставить("ProxyUser", RequestsTreeRow.ProxyUser);
	ОписаниеЗапроса.Вставить("ProxyPort", RequestsTreeRow.ProxyPort);
	ОписаниеЗапроса.Вставить("ProxyServer", RequestsTreeRow.ProxyServer);
	ОписаниеЗапроса.Вставить("Timeout", RequestsTreeRow.Timeout);
	ОписаниеЗапроса.Вставить("ТелоСтрокой", RequestsTreeRow.ТелоСтрокой);
	ОписаниеЗапроса.Вставить("ТипСтроковогоСодержимого", RequestsTreeRow.ТипСтроковогоСодержимого);
	ОписаниеЗапроса.Вставить("Комментарий", RequestsTreeRow.Комментарий);
	ОписаниеЗапроса.Вставить("НаКлиенте", RequestsTreeRow.НаКлиенте);

	//Аутентификация
	ОписаниеЗапроса.Вставить("АутентификацияВид", RequestsTreeRow.АутентификацияВид);
	ОписаниеЗапроса.Вставить("АутентификацияИспользовать", RequestsTreeRow.АутентификацияИспользовать);
	ОписаниеЗапроса.Вставить("АутентификацияПароль", RequestsTreeRow.АутентификацияПароль);
	ОписаниеЗапроса.Вставить("АутентификацияПользователь", RequestsTreeRow.АутентификацияПользователь);
	ОписаниеЗапроса.Вставить("АутентификацияПрефиксТокена", RequestsTreeRow.АутентификацияПрефиксТокена);
	ОписаниеЗапроса.Вставить("АутентификацияИмяЗаголовка", RequestsTreeRow.АутентификацияИмяЗаголовка);
	
	
	Если RequestsTreeRow.ТелоДвоичныеДанные = Неопределено Then
		ОписаниеЗапроса.Вставить("ТелоДвоичныеДанные", Неопределено);
	Иначе
		ДвоичныеДанные = УИ_ОбщегоНазначения.ЗначениеИзХранилищаКонтейнераДвоичныхДанных(RequestsTreeRow.ТелоДвоичныеДанные);
		ОписаниеЗапроса.Вставить("ТелоДвоичныеДанные", ЗначениеВСтрокуВнутр(Новый ХранилищеЗначения(ДвоичныеДанные,
			Новый СжатиеДанных(9))));
	EndIf;
	
	ОписаниеЗапроса.Вставить("Заголовки", New Array);
	
	Для Каждого Стр Из RequestsTreeRow.Заголовки Цикл
		ОписаниеЗаголовка = Новый Структура;
		ОписаниеЗаголовка.Вставить("Использование", Стр.Использование);
		ОписаниеЗаголовка.Вставить("Ключ", Стр.Ключ);
		ОписаниеЗаголовка.Вставить("Значение", Стр.Value);

		ОписаниеЗапроса.Заголовки.Добавить(ОписаниеЗаголовка);
	EndDo;
	
	ОписаниеЗапроса.Вставить("URLParameters", New Array);
	Для Каждого Стр Из RequestsTreeRow.URLParameters Цикл
		ОписаниеПараметра = Новый Структура;
		ОписаниеПараметра.Вставить("Использование", Стр.Использование);
		ОписаниеПараметра.Вставить("Имя", Стр.Name);
		ОписаниеПараметра.Вставить("Значение", Стр.Value);
		
		ОписаниеЗапроса.URLParameters.Добавить(ОписаниеПараметра);
	EndDo;
	
	ОписаниеЗапроса.Вставить("ТелоМультипарт", New Array);
	Для Каждого Стр Из RequestsTreeRow.MultipartBody Цикл
		Описание= Новый Структура;
		Описание.Вставить("Использование", Стр.Использование);
		Описание.Вставить("Имя", Стр.Name);
		Описание.Вставить("Вид", Стр.Вид);
		Описание.Вставить("Значение", Стр.Value);
		
		ОписаниеЗапроса.MultipartBody.Добавить(Описание);
	EndDo;
	
	ОписаниеЗапроса.Вставить("Строки", New Array);
	
	Для Каждого Стр Из RequestsTreeRow.ПолучитьЭлементы() Цикл
		ОписаниеЗапроса.Строки.Добавить(ОписаниеЗапросаДляСохраненияВФайл(Стр));
	EndDo;

	Return ОписаниеЗапроса;
EndFunction



&AtServer
Function ПолучитьСтрокуДанныхФайлаДляСохраненияВФайл()
	
	СохраняемыеДанные = Новый Структура;
	СохраняемыеДанные.Вставить("ВерсияФормата", 3);
	СохраняемыеДанные.Вставить("Запросы", New Array);
	
	Для Каждого СтрокаАлгоритма Из RequestsTree.ПолучитьЭлементы() Цикл
		СохраняемыеДанные.Запросы.Добавить(ОписаниеЗапросаДляСохраненияВФайл(СтрокаАлгоритма));
	EndDo;
	
	Return УИ_ОбщегоНазначенияКлиентСервер.мЗаписатьJSON(СохраняемыеДанные);

EndFunction

#EndRegion

#Область ВыполнениеЗапроса

// Выполнить запрос завершение подготовительных действий.
// 
// Параметры:
//  ПараметрыЗаврешения - Структура -  Параметры заврешения:
// * RowID - Число - 
// * НаКлиенте - Булево -
// * Файл - Структура: 
// 		** Хранение - Строка - Адрес файла во временном хранилище
// 		** ПолноеИмя - Строка 
&НаКлиенте
Процедура ВыполнитьЗапросЗавершениеПодготовительныхДействий(ПараметрыЗаврешения)
	Если ПараметрыЗаврешения.НаКлиенте Then
		ВыполнитьЗапросНаКлиенте(ПараметрыЗаврешения.RowID, ПараметрыЗаврешения.Файл);
	Иначе
		ВыполнитьЗапросНаСервере(ПараметрыЗаврешения.RowID, ПараметрыЗаврешения.Файл);
	EndIf;
КонецПроцедуры

&НаКлиенте
Процедура ВыполнитьЗапросЗавершениеЧтенияФайлаВоВременноеХранилище(Результат, ДополнительныеПараметры) Экспорт
	Если Результат = Неопределено Then
		УИ_ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось поместить файл тела во временное хранилище");
		Return;
	EndIf;
	
	Если Результат.Count() = 0 Then
		УИ_ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось поместить файл тела во временное хранилище");
		Return;
	EndIf;
	
	
	ДополнительныеПараметры.Вставить("Файл", Результат[0]);
	
	ВыполнитьЗапросЗавершениеПодготовительныхДействий(ДополнительныеПараметры);
КонецПроцедуры

&НаКлиенте
Процедура ВыполнитьЗапросЗавершениеЧтенияФайловМультипартВоВременноеХранилище(Результат, ДополнительныеПараметры) Экспорт
	Если Результат = Неопределено Then
		УИ_ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Не удалось поместить файлы тела во временное хранилище");
		Return;
	EndIf;
	
	ДополнительныеПараметры.Вставить("Файл", Результат);
	
	ВыполнитьЗапросЗавершениеПодготовительныхДействий(ДополнительныеПараметры);
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Процедура ДополнитьСписокИспользованныхРанееЗаголовков(Форма, Заголовки)
	Для Каждого КлючЗначение Из Заголовки Цикл
		Если Форма.СписокИспользованныхЗаголовков.НайтиПоЗначению(КлючЗначение.Ключ) = Неопределено Then
			Форма.СписокИспользованныхЗаголовков.Добавить(КлючЗначение.Ключ);
		EndIf;
	EndDo;
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Процедура ЗафиксироватьЛогЗапроса(Форма, RequestsTreeRow, URLДляИсполнения, АдресСервера, Протокол, HTTPЗапрос,
	HTTPОтвет, ДатаНачала, Duration)

		//	Если HTTPОтвет = Неопределено Then 
	//		Ошибка = True;
	//	Иначе 
	//		Ошибка=Не ПроверитьУспешностьВыполненияЗапроса(HTTPОтвет);//.КодСостояния<>КодУспешногоЗапроса;
	//	EndIf;
	ЗаписьЛога = RequestsTreeRow.ИсторияЗапросов.Добавить();
	ЗаписьЛога.RequestURL = URLДляИсполнения;

	ЗаписьЛога.HTTPFunction = RequestsTreeRow.HTTPRequest;
	ЗаписьЛога.АдресСервера = АдресСервера;
	ЗаписьЛога.Дата = ДатаНачала;
	ЗаписьЛога.ДлительностьВыполнения = Duration;
	ЗаписьЛога.Запрос = HTTPЗапрос.АдресРесурса;
	ЗаписьЛога.ЗаголовкиЗапроса = УИ_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуЗаголовковHTTP(HTTPЗапрос.Заголовки);
	ЗаписьЛога.BOM = RequestsTreeRow.UseBOM;
	ЗаписьЛога.RequestBodyEncoding = RequestsTreeRow.КодировкаТела;
	ЗаписьЛога.RequestBodyType = RequestsTreeRow.BodyType;
	ЗаписьЛога.Timeout = RequestsTreeRow.Timeout;

	Если RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.Строка Then
		ЗаписьЛога.ТелоЗапросаСтрока = HTTPЗапрос.GetBodyAsString();
	ElsIf RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.Файл Then
		ЗаписьЛога.ТелоЗапросаИмяФайла = RequestsTreeRow.ИмяФайлаТела;
	ElsIf RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.БезТела Then
	Иначе
		ДвоичныеДанныеТела = HTTPЗапрос.GetBodyAsBinaryData();
		ЗаписьЛога.ТелоЗапросаАдресДвоичныхДанных = ПоместитьВоВременноеХранилище(ДвоичныеДанныеТела,
																				  Форма.УникальныйИдентификатор);
		ЗаписьЛога.BinaryDataRequestBodyString = Строка(ДвоичныеДанныеТела);
	EndIf;

	ЗаписьЛога.Протокол = Протокол;

	// Прокси
	ЗаписьЛога.UseProxy = RequestsTreeRow.UseProxy;
	ЗаписьЛога.ProxyServer = RequestsTreeRow.ProxyServer;
	ЗаписьЛога.ProxyPort = RequestsTreeRow.ProxyPort;
	ЗаписьЛога.ProxyUser = RequestsTreeRow.ProxyUser;
	ЗаписьЛога.ProxyPassword = RequestsTreeRow.ProxyPassword;
	ЗаписьЛога.ProxyOSAuthentication = RequestsTreeRow.ProxyOSAuthentication;

	ЗаписьЛога.StatusCode = ?(HTTPОтвет = Неопределено, 500, HTTPОтвет.КодСостояния);

	Если HTTPОтвет = Неопределено Then
		Return;
	EndIf;

	ЗаписьЛога.ResponseHeaders = УИ_ОбщегоНазначенияКлиентСервер.ПолучитьСтрокуЗаголовковHTTP(HTTPОтвет.Заголовки);

	СтрокаТелоОтвета = HTTPОтвет.GetBodyAsString();
	Если ValueIsFilled(СтрокаТелоОтвета) Then
#Если Сервер Then
		Если НайтиНедопустимыеСимволыXML(СтрокаТелоОтвета) = 0 Then
			АдресТелаОтветаСтрокой = ПоместитьВоВременноеХранилище(СтрокаТелоОтвета, Форма.УникальныйИдентификатор);
		Иначе
			АдресТелаОтветаСтрокой = ПоместитьВоВременноеХранилище("Содержит недопустимые символы XML",
																   Форма.УникальныйИдентификатор);
		EndIf;
#Иначе

			Попытка
				АдресТелаОтветаСтрокой = ПоместитьВоВременноеХранилище(СтрокаТелоОтвета, Форма.УникальныйИдентификатор);
			Исключение
				АдресТелаОтветаСтрокой = ПоместитьВоВременноеХранилище("Содержит недопустимые символы XML",
																	   Форма.УникальныйИдентификатор);
			КонецПопытки;
#EndIf
		ЗаписьЛога.АдресТелаОтветаСтрокой = АдресТелаОтветаСтрокой;
	EndIf;
	ДвоичныеДанныеОтвета = HTTPОтвет.GetBodyAsBinaryData();
	Если ДвоичныеДанныеОтвета <> Неопределено Then
		ЗаписьЛога.ТелоОтветаАдресДвоичныхДанных = ПоместитьВоВременноеХранилище(ДвоичныеДанныеОтвета,
			Форма.УникальныйИдентификатор);
		ЗаписьЛога.ТелоОтветаДвоичныеДанныеСтрокой = Строка(ДвоичныеДанныеОтвета);
	EndIf;

	ИмяФайлаОтвета = HTTPОтвет.ПолучитьИмяФайлаТела();
	Если ИмяФайлаОтвета <> Неопределено Then
		Файл = New File(ИмяФайлаОтвета);
		Если Файл.Существует() Then
			ДвоичныеДанныеОтвета = New BinaryData(ИмяФайлаОтвета);
			ЗаписьЛога.ТелоОтветаАдресДвоичныхДанных = ПоместитьВоВременноеХранилище(ДвоичныеДанныеОтвета,
				Форма.УникальныйИдентификатор);
			ЗаписьЛога.ТелоОтветаДвоичныеДанныеСтрокой = Строка(ДвоичныеДанныеОтвета);
		EndIf;
	EndIf;
	
	RequestsTreeRow.ИсторияЗапросов.Сортировать("Дата Убыв");
	
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Процедура ЗаполнитьРезультатЗапросаПоЗаписиИстории(Форма, RequestsTreeRow, СтрокаИсторииЗапросов = Неопределено)
	Если СтрокаИсторииЗапросов = Неопределено Then
		Форма.StatusCode = 0;
		Форма.ResponseHeaders = "";
		Форма.ResponseBodyString = "";
		Форма.DurationInMilliseconds = 0;
		Форма.ТелоОтветаДвоичныеДанныеСтрокой = "";
		Форма.ТелоОтветаАдресДвоичныхДанных = "";

		Return;
	EndIf;

	Форма.StatusCode = СтрокаИсторииЗапросов.StatusCode;
	Форма.ResponseHeaders = СтрокаИсторииЗапросов.ResponseHeaders;
	Если ЭтоАдресВременногоХранилища(СтрокаИсторииЗапросов.АдресТелаОтветаСтрокой) Then
		Форма.ResponseBodyString = ПолучитьИзВременногоХранилища(СтрокаИсторииЗапросов.АдресТелаОтветаСтрокой);
	Иначе
		Форма.ResponseBodyString = "";
	EndIf;
	Форма.DurationInMilliseconds = СтрокаИсторииЗапросов.ДлительностьВыполнения;
	Форма.StatusCode = СтрокаИсторииЗапросов.StatusCode;
	Форма.ТелоОтветаДвоичныеДанныеСтрокой = СтрокаИсторииЗапросов.ТелоОтветаДвоичныеДанныеСтрокой;
	Форма.ТелоОтветаАдресДвоичныхДанных = СтрокаИсторииЗапросов.ТелоОтветаАдресДвоичныхДанных;
КонецПроцедуры

#EndRegion

#Область СписокЗапросов

&НаКлиенте 
Процедура СохранитьДанныеЗапросаВДеревоЗапросов()
	Если УИ_ИдентификаторТекущейСтрокиЗапросов = Неопределено Then
		Return;
	EndIf;
	ТекДанные = RequestsTree.FindByID(УИ_ИдентификаторТекущейСтрокиЗапросов);
	Если ТекДанные = Неопределено Then
		Return;
	EndIf;

	//Заголовки 
	ТекДанные.Заголовки.Очистить();
	Если РедактированиеЗаголовковТаблицей Then
		Для Каждого СтрокаЗаголовка Из RequestHeadersTable Цикл
			НоваяСтрока = ТекДанные.Заголовки.Добавить();
			НоваяСтрока.Ключ = СтрокаЗаголовка.Ключ;
			НоваяСтрока.Value = СтрокаЗаголовка.Value;
			НоваяСтрока.Использование = СтрокаЗаголовка.Использование;
		EndDo;
	Иначе
		Заголовки = УИ_ОбщегоНазначенияКлиентСервер.ЗаголовкиHTTPЗапросаИзСтроки(ЗаголовкиСтрока);
		Для Каждого КлючЗначение ИЗ Заголовки Цикл
			НоваяСтрока = ТекДанные.Заголовки.Добавить();
			НоваяСтрока.Ключ = КлючЗначение.Ключ;
			НоваяСтрока.Value = КлючЗначение.Value;
			НоваяСтрока.Использование = True;
		EndDo;
	EndIf;
		

//	ТекДанные.Текст = УИ_РедакторКодаКлиент.ТекстКодаРедактора(ЭтотОбъект, "Код");
//	ТекДанные.ИспользоватьОбработкуДляВыполненияКода = УИ_РедакторКодаКлиент.РежимИспользованияОбработкиДляВыполненияКодаРедактора(ЭтотОбъект,
//																																   "Код");
	
КонецПроцедуры

&НаКлиенте
Процедура ИзвлечьДанныеЗапросаИзСтрокиДерева()
	СтрокаДерева = ТекущаяСтрокаЗапросов();
	Если СтрокаДерева = Неопределено Then
		Return;
	EndIf;
	
	//Заголовки 
	RequestHeadersTable.Очистить();
	ЗаголовкиСтрока = "";
	Если РедактированиеЗаголовковТаблицей Then
		Для Каждого Стр Из СтрокаДерева.Заголовки Цикл
			НоваяСтрока = RequestHeadersTable.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Стр);
		EndDo;
	Иначе
		ЗаголовкиСтрока = СтрокаЗаголовковПоТаблице(СтрокаДерева.Заголовки);
	EndIf;
	
	ТелоЗапросаДвоичныеДанныеСтрокой = "";
	Если СтрокаДерева.ТелоДвоичныеДанные <> Неопределено Then
		ХранилищеДвоичныхДанных = СтрокаДерева.ТелоДвоичныеДанные; //см. УИ_ОбщегоНазначенияКлиентСервер.НовыйХранилищеЗначенияТипаДвоичныеДанные
		ТелоЗапросаДвоичныеДанныеСтрокой = ХранилищеДвоичныхДанных.Представление;
	EndIf;

	ПриИзмененииВидаТелаЗапроса();
	ПриИзмененииВидаАутентификацииЗапроса();

	Если СтрокаДерева.ИсторияЗапросов.Count() > 0 Then
		ЗаполнитьРезультатЗапросаПоЗаписиИстории(ЭтотОбъект,
												 СтрокаДерева,
												 СтрокаДерева.ИсторияЗапросов[0]);
	Иначе
		ЗаполнитьРезультатЗапросаПоЗаписиИстории(ЭтотОбъект,
												 СтрокаДерева,
												 Неопределено);
		
	EndIf;
	УстановитьПредварительныйURL(СтрокаДерева.ПолучитьИдентификатор());
КонецПроцедуры



#EndRegion

#Область ПодготовкаЗапроса

&НаКлиентеНаСервереБезКонтекста
Процедура ЗаполнитьТаблицуЗаголовковПоСтроке(СтрокаЗаголовков, RequestHeadersTable)
	RequestHeadersTable.Очистить();
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(СтрокаЗаголовков);
	Для НомерСтроки = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		ЗаголовокСтр = ТекстовыйДокумент.ПолучитьСтроку(НомерСтроки);

		Если Не ValueIsFilled(ЗаголовокСтр) Then
			Continue;
		EndIf;

		МассивЗаголовка = СтрРазделить(ЗаголовокСтр, ":");
		Если МассивЗаголовка.Count() <> 2 Then
			Continue;
		EndIf;

		НС = RequestHeadersTable.Добавить();
		НС.Ключ = МассивЗаголовка[0];
		НС.Value = МассивЗаголовка[1];
		НС.Использование = True;

	EndDo;
	
КонецПроцедуры

&НаКлиенте
Процедура УстановитьСтраницуРедактированияЗаголовковЗапроса()
	Если РедактированиеЗаголовковТаблицей Then
		НоваяСтраница = Элементы.EditRequestHeadersPageGroupAsTable;
	Иначе
		НоваяСтраница = Элементы.EditRequestHeadersPageGroupAsText;
	EndIf;

	Элементы.EditRequestHeadersPagesGroup.ТекущаяСтраница = НоваяСтраница;

	//Теперь нужно заполнить заголовки на новой странице по старой странице
	Если РедактированиеЗаголовковТаблицей Then
		ЗаполнитьТаблицуЗаголовковПоСтроке(ЗаголовкиСтрока, RequestHeadersTable);
	Иначе
		ЗаголовкиСтрока = СтрокаЗаголовковПоТаблице(RequestHeadersTable);
	EndIf;
КонецПроцедуры

#EndRegion

#Область ИсполнениеЗапроса

&НаКлиентеНаСервереБезКонтекста
Процедура ВыполнитьЗапросНаКлиентеНаСервере(Форма, СтрокаДерева, ДанныеФайлаТела = Неопределено)
	URLДляИсполнения = URLДляИсполнения(СтрокаДерева);
	StructureURL = UT_HTTPConnector.ParseURL(URLДляИсполнения);

	HTTPConnection = ПодготовленноеСоединение(Форма, СтрокаДерева, StructureURL);

	StartExecution = CurrentUniversalDateInMilliseconds();
	Запрос = ПодготовленныйЗапросHTTP(Форма, СтрокаДерева, StructureURL, ДанныеФайлаТела);
	#Если НаКлиенте Then
	ДатаНачала = ТекущаяДата();
	#Иначе
	ДатаНачала = ТекущаяДатаСеанса();
	#EndIf
	
	ПараметрыОбработкиРезультатаВыполненияЗапроса = Новый Структура;
	ПараметрыОбработкиРезультатаВыполненияЗапроса.Вставить("Форма", Форма);
	ПараметрыОбработкиРезультатаВыполненияЗапроса.Вставить("СтрокаДерева", СтрокаДерева);
	ПараметрыОбработкиРезультатаВыполненияЗапроса.Вставить("HTTPConnection", HTTPConnection);
	ПараметрыОбработкиРезультатаВыполненияЗапроса.Вставить("Запрос", Запрос);
	ПараметрыОбработкиРезультатаВыполненияЗапроса.Вставить("StartExecution", StartExecution);
	ПараметрыОбработкиРезультатаВыполненияЗапроса.Вставить("ДатаНачала", ДатаНачала);
	ПараметрыОбработкиРезультатаВыполненияЗапроса.Вставить("URLДляИсполнения", URLДляИсполнения);
	ПараметрыОбработкиРезультатаВыполненияЗапроса.Вставить("StructureURL", StructureURL);
	ПараметрыОбработкиРезультатаВыполненияЗапроса.Вставить("ДанныеФайлаТела", ДанныеФайлаТела);
	
#Если Клиент Then
	//@skip-check wrong-string-literal-content
	ОповещениеОЗавершенииВыполненияЗапроса = Новый ОписаниеОповещения("ПослеВыполненияЗапросаНаКлиенте", Форма,
		ПараметрыОбработкиРезультатаВыполненияЗапроса);
#EndIf	
	
	Попытка
		Если УИ_ОбщегоНазначенияКлиентСервер.ВерсияПлатформыНеМладше("8.3.21")
			 И СтрокаДерева.НаКлиенте Then
			Если СтрокаДерева.HTTPRequest = Форма.ВидыHTTPМетодов.GET Then
				Ответ = HTTPConnection.ПолучитьАсинх(Запрос);
			ElsIf СтрокаДерева.HTTPRequest = Форма.ВидыHTTPМетодов.POST Then
				Ответ = HTTPConnection.ОтправитьДляОбработкиАсинх(Запрос);
			ElsIf СтрокаДерева.HTTPRequest = Форма.ВидыHTTPМетодов.DELETE Then
				Ответ = HTTPConnection.УдалитьАсинх(Запрос);
			ElsIf СтрокаДерева.HTTPRequest = Форма.ВидыHTTPМетодов.PUT Then
				Ответ = HTTPConnection.ЗаписатьАсинх(Запрос);
			ElsIf СтрокаДерева.HTTPRequest = Форма.ВидыHTTPМетодов.PATCH Then
				Ответ = HTTPConnection.ИзменитьАсинх(Запрос);
			Иначе
				Ответ = HTTPConnection.CallHTTPMethodAsync(СтрокаДерева.HTTPRequest, Запрос);
			EndIf;
#Если Клиент Then
			УИ_МетодыСовмеcтимостиПлатформы_8_3_18Клиент.ЗадатьОповещениеДляОбещания(Ответ,
																					 ОповещениеОЗавершенииВыполненияЗапроса);
			Return;
#EndIf
		Иначе
			Если СтрокаДерева.HTTPRequest = Форма.ВидыHTTPМетодов.GET Then
				Ответ = HTTPConnection.Получить(Запрос);
			ElsIf СтрокаДерева.HTTPRequest = Форма.ВидыHTTPМетодов.POST Then
				Ответ = HTTPConnection.ОтправитьДляОбработки(Запрос);
			ElsIf СтрокаДерева.HTTPRequest = Форма.ВидыHTTPМетодов.DELETE Then
				Ответ = HTTPConnection.Удалить(Запрос);
			ElsIf СтрокаДерева.HTTPRequest = Форма.ВидыHTTPМетодов.PUT Then
				Ответ = HTTPConnection.Записать(Запрос);
			ElsIf СтрокаДерева.HTTPRequest = Форма.ВидыHTTPМетодов.PATCH Then
				Ответ = HTTPConnection.Изменить(Запрос);
			Иначе
				Ответ = HTTPConnection.CallHTTPMethod(СтрокаДерева.HTTPRequest, Запрос);
			EndIf;
			ПараметрыОбработкиРезультатаВыполненияЗапроса.Вставить("Ответ", Ответ);
		EndIf;
	Исключение
		УИ_ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ОписаниеОшибки());
		
		ПараметрыОбработкиРезультатаВыполненияЗапроса.Вставить("Ответ", Неопределено);
	КонецПопытки;
	ПослеВыполненияЗапросаНаКлиентеНаСервере(ПараметрыОбработкиРезультатаВыполненияЗапроса);

КонецПроцедуры

&НаКлиенте
Процедура ВыполнитьЗапросНаКлиенте(ИдентификаторСтрокиДерева, ДанныеФайлаТела = Неопределено)
	СтрокаДерева = RequestsTree.FindByID(ИдентификаторСтрокиДерева);
	Если СтрокаДерева = Неопределено Then
		Return;
	EndIf;
	
	ВыполнитьЗапросНаКлиентеНаСервере(ЭтотОбъект, СтрокаДерева, ДанныеФайлаТела);
	
КонецПроцедуры

&AtServer
Процедура ВыполнитьЗапросНаСервере(ИдентификаторСтрокиДерева, ДанныеФайлаТела = Неопределено)
	СтрокаДерева = RequestsTree.FindByID(ИдентификаторСтрокиДерева);
	Если СтрокаДерева = Неопределено Then
		Return;
	EndIf;
	
	ВыполнитьЗапросНаКлиентеНаСервере(ЭтотОбъект, СтрокаДерева, ДанныеФайлаТела);
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Function ПодготовленноеСоединение(Форма, RequestsTreeRow, StructureURL)
	Порт = Неопределено;
	Если ValueIsFilled(StructureURL.Порт) Then
		Порт = StructureURL.Порт;
	EndIf;
		
	НастройкаПрокси = Неопределено;
	Если RequestsTreeRow.UseProxy Then
#Если Не ВебКлиент Then
		НастройкаПрокси = Новый ИнтернетПрокси(True);
		НастройкаПрокси.Установить(StructureURL.Схема,
								   RequestsTreeRow.ProxyServer,
								   RequestsTreeRow.ProxyPort,
								   RequestsTreeRow.ProxyUser,
								   RequestsTreeRow.ProxyPassword,
								   RequestsTreeRow.ProxyOSAuthentication);
#EndIf
	EndIf;

	ИспользоватьNTMLАутентификацию = Неопределено;
	Если УИ_ОбщегоНазначенияКлиентСервер.ВерсияПлатформыНеМладше("8.3.7") Then
		Если RequestsTreeRow.АутентификацияИспользовать
			 И RequestsTreeRow.АутентификацияВид = ВидыАутентификации().NTML Then
			ИспользоватьNTMLАутентификацию = True;
		EndIf;
	EndIf;

	ЗащищенноеСоединение = Неопределено;
	Если НРег(StructureURL.Схема) = "https" Then
		ЗащищенноеСоединение = УИ_МетодыСовместимостиПлатформы_8_3_21КлиентСервер.НовыйЗащищенноеСоединениеOpenSSL();
	EndIf;

	Return УИ_МетодыСовместимостиПлатформы_8_3_21КлиентСервер.НовыйHTTPСоединение(StructureURL.Сервер,
																				   Порт,
																				   ,
																				   ,
																				   НастройкаПрокси,
																				   RequestsTreeRow.Timeout,
																				   ЗащищенноеСоединение,
																				   ИспользоватьNTMLАутентификацию);

EndFunction

&НаКлиентеНаСервереБезКонтекста
Function ПодготовленныйЗапросHTTP(Форма, RequestsTreeRow, StructureURL, ДанныеФайлаТела)
	Заголовки = Новый Соответствие;

	СтрокаЗапроса = StructureURL.Путь;

	СтрокаПараметров = "";
	Для Каждого КлючЗначение Из StructureURL.ПараметрыЗапроса Цикл
		СтрокаПараметров = СтрокаПараметров
						   + ?(Не ValueIsFilled(СтрокаПараметров), "?", "&")
						   + КлючЗначение.Ключ
						   + "="
						   + КлючЗначение.Value;
	EndDo;

	АдресРесурса = СтрокаЗапроса + СтрокаПараметров;
	
	ТелоПараметры = Новый Структура;
	ТелоПараметры.Вставить("Тело", Неопределено);
	ТелоПараметры.Вставить("ТелоКодировка", Неопределено);
	ТелоПараметры.Вставить("ТелоБОМ", Неопределено);
	
	Если RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.БезТела Then
		//Ничего не делаем. тела нету
	ElsIf RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.Строка Then
		Если ValueIsFilled(RequestsTreeRow.ТелоСтрокой) Then
#Если ВебКлиент Then
			БОМ = Неопределено;
			Если RequestsTreeRow.UseBOM <> 0 Then
				УИ_ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Настройка использования BOM игнорируется на веб клиенте");
			EndIf;
#Иначе
				Если RequestsTreeRow.UseBOM = 0 Then
					БОМ = ИспользованиеByteOrderMark.Авто;
				ElsIf (RequestsTreeRow.UseBOM = 1) Then
					БОМ = ИспользованиеByteOrderMark.Использовать;
				Иначе
					БОМ = ИспользованиеByteOrderMark.НеИспользовать;
				EndIf;
#EndIf                
			ТелоПараметры.ТелоБОМ = БОМ;
			БезКодировкиТекста = RequestsTreeRow.КодировкаТела = "Auto";
#Если ВебКлиент Then
			Если Не БезКодировкиТекста Then
				БезКодировкиТекста = True;
				УИ_ОбщегоНазначенияКлиентСервер.СообщитьПользователю("При запросе в вебклиенте тело устанавливается в кодровке UTF-8 и настройка кодировки игнорируется");
			EndIf;

#EndIf
			ТелоПараметры.Тело = RequestsTreeRow.ТелоСтрокой;

			Если Не БезКодировкиТекста Then
				Попытка
					КодировкаТела = УИ_МетодыСовместимостиПлатформы_8_3_21КлиентСервер.КодировкаТекстаПоИмени(RequestsTreeRow.КодировкаТела);
				Исключение
					КодировкаТела = RequestsTreeRow.КодировкаТела;
				КонецПопытки;
				ТелоПараметры.ТелоКодировка = КодировкаТела;
			EndIf;
		EndIf;
	ElsIf RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.ДвоичныеДанные Then
		Если RequestsTreeRow.ТелоДвоичныеДанные <> Неопределено Then
			ДвоичныеДанныеТела = УИ_ОбщегоНазначения.ЗначениеИзХранилищаКонтейнераДвоичныхДанных(RequestsTreeRow.ТелоДвоичныеДанные);
			
			Если ТипЗнч(ДвоичныеДанныеТела) = Тип("ДвоичныеДанные") Then 
				ТелоПараметры.Тело = ДвоичныеДанныеТела;	
			EndIf;
		EndIf;
	ElsIf RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.МультипартФорм Then
		MultypartItemsType = MultypartItemsType();
		РазделительСтрокДляЗапросаMultipart = РазделительСтрокДляЗапросаMultipart();
		
		FilesToCombine = New Array;
		Для RowIndex = 0 По RequestsTreeRow.MultipartBody.Count() - 1 Цикл
			MultypartItemRow = RequestsTreeRow.MultipartBody[RowIndex];
			Если Не MultypartItemRow.Using Then
				Continue;
			EndIf;
			
			Если MultypartItemRow.Type = MultypartItemsType.String Then

				InputFile = ""
							  + РазделительСтрокДляЗапросаMultipart
							  + "--"
							  + Форма.MultipartBodySplitter
							  + РазделительСтрокДляЗапросаMultipart
							  + "Content-Disposition: form-data;name="""
							  + MultypartItemRow.Name
							  + """"
							  + РазделительСтрокДляЗапросаMultipart 
							  + РазделительСтрокДляЗапросаMultipart;

				FilesToCombine.Добавить(GetBinaryDataFromString(InputFile));

				FilesToCombine.Добавить(GetBinaryDataFromString(MultypartItemRow.Value));

			ElsIf MultypartItemRow.Type = MultypartItemsType.File Then
				Если Не ValueIsFilled(MultypartItemRow.Value) Then
					Continue;
				EndIf;

				АдресДвоичныхДанных = ДанныеФайлаТела[RowIndex];
				Если АдресДвоичныхДанных = Неопределено Then
					Continue;
				EndIf;
				Если Не ЭтоАдресВременногоХранилища(АдресДвоичныхДанных) Then
					Continue;
				EndIf;


				Файл = New File(MultypartItemRow.Value);

				InputFile = ""
							  + РазделительСтрокДляЗапросаMultipart
							  + "--"
							  + Форма.MultipartBodySplitter
							  + РазделительСтрокДляЗапросаMultipart
							  + "Content-Disposition: form-data;name="""
							  + MultypartItemRow.Name
							  + """;filename="""
							  + Файл.Name
							  + """"
							  + РазделительСтрокДляЗапросаMultipart
							  + "Content-Type: application/octet-stream"
							  + РазделительСтрокДляЗапросаMultipart
							  + РазделительСтрокДляЗапросаMultipart;

				FilesToCombine.Добавить(GetBinaryDataFromString(InputFile));
				FilesToCombine.Добавить(ПолучитьИзВременногоХранилища(АдресДвоичныхДанных));
			EndIf;
				
		EndDo;

		InputFile = ""
					  + РазделительСтрокДляЗапросаMultipart
					  + "--"
					  + Форма.MultipartBodySplitter
					  + "--"
					  + РазделительСтрокДляЗапросаMultipart;

		FilesToCombine.Добавить(GetBinaryDataFromString(InputFile));

		FinalBD = ConcatBinaryData(FilesToCombine);

		РазмерФайлаОтправки = Формат(FinalBD.Размер(), "ЧГ=0;");
		ТелоПараметры.Тело = FinalBD;
		
		Заголовки.Вставить("Content-Length", РазмерФайлаОтправки);		
	Иначе
		Если RequestsTreeRow.НаКлиенте Then      
			ТелоПараметры.Тело = ДанныеФайлаТела.ПолноеИмя;
		Иначе
#Если Не ВебКлиент Then
			ДвоичныеДанныеТела = ПолучитьИзВременногоХранилища(ДанныеФайлаТела.Хранение);
			Если ТипЗнч(ДвоичныеДанныеТела) = Тип("ДвоичныеДанные") Then
				Файл = New File(RequestsTreeRow.ИмяФайлаТела);
			//@skip-check missing-temporary-file-deletion
				ВременныйФайл = ПолучитьИмяВременногоФайла(Файл.Расширение);
				ДвоичныеДанныеТела.Записать(ВременныйФайл);

				ТелоПараметры.Тело = ВременныйФайл;

				Заголовки.Вставить("Content-Length", Формат(ДвоичныеДанныеТела.Размер(), "ЧГ=0;"));

			EndIf;
#EndIf
		EndIf;
	EndIf;

	//Теперь нужно установить заголовки запроса

	Для Каждого СтрокаЗаголовка Из RequestsTreeRow.Заголовки Цикл
		Если Не СтрокаЗаголовка.Использование Then
			Continue;
		EndIf;
		Заголовки.Вставить(СтрокаЗаголовка.Ключ, СтрокаЗаголовка.Value);
	EndDo;

	УстановитьЗаголовокАутентификацииВЗапросHTTP(RequestsTreeRow, Заголовки);
	NewRequest = УИ_МетодыСовместимостиПлатформы_8_3_21КлиентСервер.НовыйHTTPЗапрос(АдресРесурса, Заголовки);
	
	Если RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.Строка Then
		Если ТелоПараметры.ТелоКодировка = Неопределено Then
			//@skip-check unknown-method-property
			NewRequest.УстановитьТелоИзСтроки(ТелоПараметры.Тело, , ТелоПараметры.ТелоБОМ);
		Иначе
			//@skip-check unknown-method-property
			NewRequest.УстановитьТелоИзСтроки(ТелоПараметры.Тело, ТелоПараметры.ТелоКодировка, ТелоПараметры.ТелоБОМ);
		EndIf;
	ElsIf RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.ДвоичныеДанные Then
		Если ТипЗнч(ТелоПараметры.Тело) = Тип("ДвоичныеДанные") Then
			//@skip-check unknown-method-property
			NewRequest.SetBodyFromBinaryData(ТелоПараметры.Тело);
		EndIf;
	ElsIf RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.МультипартФорм Then
		//@skip-check unknown-method-property
		NewRequest.SetBodyFromBinaryData(ТелоПараметры.Тело);
	ElsIf RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.Файл Then
		Если ТелоПараметры.Тело <> Неопределено Then
			//@skip-check unknown-method-property
			NewRequest.SetBodyFileName(ТелоПараметры.Тело);
		EndIf;
	EndIf;
	Return NewRequest;
EndFunction

&НаКлиентеНаСервереБезКонтекста
Процедура УстановитьЗаголовокАутентификацииВЗапросHTTP(RequestsTreeRow, ЗаголовкиЗапроса)
	Виды = ВидыАутентификации();
	Если Не ValueIsFilled(RequestsTreeRow.АутентификацияВид)
		 Или RequestsTreeRow.АутентификацияВид = Виды.Нет Then
		Return;
	EndIf;
	
	Если Не RequestsTreeRow.АутентификацияИспользовать Then
		Return;
	EndIf;
	
	ИмяЗаголовка = "Authorization";
	Если ЗаголовкиЗапроса.Получить(ИмяЗаголовка) <> Неопределено Then
		Return;
	EndIf;
	
	ЗначениеЗаголовка = "";
	
	Если RequestsTreeRow.АутентификацияВид = Виды.Базовая Then
		Префикс = "Basic";

		ЗначениеЗаголовка = Префикс
							+ " "
							+ Base64Строка(GetBinaryDataFromString(RequestsTreeRow.АутентификацияПользователь
																		  + ":"
																		  + RequestsTreeRow.АутентификацияПароль));

	ElsIf RequestsTreeRow.АутентификацияВид = Виды.BearerToken Then 
		Префикс = СокрЛП(RequestsTreeRow.АутентификацияПрефиксТокена);
		Если Не ValueIsFilled(Префикс) Then
			Префикс = "Bearer";
		EndIf;
		ЗначениеЗаголовка = Префикс +" "+ RequestsTreeRow.АутентификацияПароль;
	Иначе
		Return;
	EndIf;
	
	ЗаголовкиЗапроса.Вставить(ИмяЗаголовка, ЗначениеЗаголовка);
КонецПроцедуры

// После выполнения запроса на клиенте на сервере.
// 
// Параметры:
//  ДополнительныеПараметры - Структура -  Дополнительные параметры:
// * Форма - УправляемаяФорма - 
// * СтрокаДерева - ДанныеФормыЭлементДерева - 
// * HTTPConnection - HTTPСоединение - 
// * Запрос - HTTPЗапрос - 
// * StartExecution - Число - 
// * ДатаНачала - Дата - 
// * URLДляИсполнения - Строка -
// * StructureURL - Структура - :
// ** Схема - Строка - 
// ** Аутентификация - Структура - :
// *** Пользователь - Строка - 
// *** Пароль - Строка - 
// ** Сервер - Строка - 
// ** Порт - Число - 
// ** Путь - Строка, Число - 
// ** ПараметрыЗапроса - Соответствие - 
// ** Фрагмент - Строка - 
// * ДанныеФайлаТела - Структура, Неопределено - :
// ** Хранение - Строка - 
// ** ПолноеИмя - Строка - 
// * Ответ - HTTPОтвет - 
&НаКлиентеНаСервереБезКонтекста
Процедура ПослеВыполненияЗапросаНаКлиентеНаСервере(ДополнительныеПараметры)
	FinishExecution = CurrentUniversalDateInMilliseconds();

	ДлительностьВМилисекундах = FinishExecution - ДополнительныеПараметры.StartExecution;

	ЗафиксироватьЛогЗапроса(ДополнительныеПараметры.Форма,
							ДополнительныеПараметры.СтрокаДерева,
							ДополнительныеПараметры.URLДляИсполнения,
							ДополнительныеПараметры.StructureURL.Сервер,
							ДополнительныеПараметры.StructureURL.Схема,
							ДополнительныеПараметры.Запрос,
							ДополнительныеПараметры.Ответ,
							ДополнительныеПараметры.ДатаНачала,
							ДлительностьВМилисекундах);

	ЗаполнитьРезультатЗапросаПоЗаписиИстории(ДополнительныеПараметры.Форма,
											 ДополнительныеПараметры.СтрокаДерева,
											 ДополнительныеПараметры.СтрокаДерева.ИсторияЗапросов[0]);

	ДополнитьСписокИспользованныхРанееЗаголовков(ДополнительныеПараметры.Форма,
												 ДополнительныеПараметры.Запрос.Заголовки);

	ИмяФайлаТела = ДополнительныеПараметры.Запрос.ПолучитьИмяФайлаТела();
	Если ИмяФайлаТела <> Неопределено Then
		//@skip-check empty-except-statement
		Попытка
			УдалитьФайлы(ИмяФайлаТела);
		Исключение
		КонецПопытки;
	EndIf;
	Если ДополнительныеПараметры.ДанныеФайлаТела <> Неопределено Then
		Если ТипЗнч(ДополнительныеПараметры.ДанныеФайлаТела) = Тип("Структура") Then
		//@skip-check empty-except-statement
			Попытка
				УдалитьИзВременногоХранилища(ДополнительныеПараметры.ДанныеФайлаТела.Хранение);
			Исключение
			КонецПопытки;
		ElsIf ТипЗнч(ДополнительныеПараметры.ДанныеФайлаТела) = Тип("Соответствие") Then
			Для Каждого КлючЗначение Из ДополнительныеПараметры.ДанныеФайлаТела Цикл
			//@skip-check empty-except-statement
				Попытка
					УдалитьИзВременногоХранилища(КлючЗначение.Value);
				Исключение
				КонецПопытки;
			EndDo;
		EndIf;
	EndIf;
	
	
КонецПроцедуры

&НаКлиенте 
Процедура ПослеВыполненияЗапросаНаКлиенте(ОтветСервера, ДополнительныеПараметры) Экспорт
	Если ТипЗнч(ОтветСервера) = Тип("ИнформацияОбОшибке") Then
		УИ_ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ОтветСервера.Описание);
		Ответ = Неопределено;
	Иначе
		Ответ = ОтветСервера;
	EndIf;
		
	ДополнительныеПараметры.Вставить("Ответ", Ответ);
	
	ПослеВыполненияЗапросаНаКлиентеНаСервере(ДополнительныеПараметры);	
КонецПроцедуры

#EndRegion

#Область РезультатЗапроса

#EndRegion

#Область Общее

&AtServerNoContext
Function URLДляИсполненияСЗакодированнымиПараметрами(URL, Параметры)
	Return УИ_КоннекторHTTP.УИ_ПодготовленныйURL(URL, Параметры);
EndFunction

&НаКлиентеНаСервереБезКонтекста
Function URLДляИсполнения(RequestsTreeRow)
	URLParameters = Новый Соответствие;
	
	Для Каждого Стр Из RequestsTreeRow.URLParameters Цикл
		Если Не Стр.Использование Then
			Continue;
		EndIf;
		Если Не ValueIsFilled(Стр.Name) Then
			Continue;
		EndIf;
		
		МассивИмени = URLParameters[Стр.Name];
		Если МассивИмени = Неопределено Then
			URLParameters.Вставить(Стр.Name, New Array);
			МассивИмени = URLParameters[Стр.Name];
		EndIf;
		МассивИмени.Добавить(Стр.Value);
	EndDo;
	
	Return URLДляИсполненияСЗакодированнымиПараметрами(RequestsTreeRow.RequestURL, URLParameters);
EndFunction

&AtServer
Процедура УстановитьПредварительныйURL(ИдентификаторСтрокиДерева)
	URLПредварительный = "";
	Если ИдентификаторСтрокиДерева = Неопределено Then
		Return;
	EndIf;
	
	ТекСтрокаДерева = RequestsTree.FindByID(ИдентификаторСтрокиДерева);
	Если ТекСтрокаДерева = Неопределено Then
		Return;
	EndIf;
		
	URLПредварительный = URLДляИсполнения(ТекСтрокаДерева)
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Function РазделительСтрокДляЗапросаMultipart()
	Return Символы.ВК + Chars.LF;
EndFunction

&НаКлиенте
Function ВозможноИсполнениеЗапроса(СтрокаЗапросов)
	Если Не СтрокаЗапросов.НаКлиенте Then
		Return True;
	EndIf;	
	
	Если Не УИ_ОбщегоНазначенияКлиент.ЭтоВебКлиент() Then
		Return True;
	EndIf;		
	
	Результат = True;

	Если Не УИ_ОбщегоНазначенияКлиентСервер.ВерсияПлатформыНеМладше("8.3.21") Then
		УИ_ОбщегоНазначенияКлиентСервер.СообщитьПользователю("Запросы в контексте веб-клиента доступны, начиная с версии платформы 8.3.21");
		Результат = Ложь;
	EndIf;

	Если СтрокаЗапросов.UseProxy Then
		УИ_ОбщегоНазначенияКлиентСервер.СообщитьПользователю("В веб клиенте не поддерживается использование прокси в HTTP запросах");
		Результат = Ложь;
	EndIf;
	
	Return Результат;
EndFunction

&НаКлиентеНаСервереБезКонтекста
Function СтрокаЗаголовковПоТаблице(ТаблицаЗаголовков)
	МассивСтрокЗаголовков = New Array;
	Для Каждого Стр Из ТаблицаЗаголовков Цикл
		Если Не Стр.Использование Then
			Continue;
		EndIf;
		МассивСтрокЗаголовков.Добавить(Стр.Ключ + ":" + Стр.Value);
	EndDo;

	Return StrConcat(МассивСтрокЗаголовков, Chars.LF);

EndFunction

&НаКлиентеНаСервереБезКонтекста
Function ВидыКодировокТелаЗапроса()
	Виды = Новый Структура;
	Виды.Вставить("Auto", "Auto");
	Виды.Вставить("Системная", "Системная");
	Виды.Вставить("ANSI", "ANSI");
	Виды.Вставить("OEM", "OEM");
	Виды.Вставить("UTF8", "UTF8");
	Виды.Вставить("UTF16", "UTF16");
	
	
	Return Виды;
EndFunction

&AtServer
Процедура ЗаполнитьСписокВыбораКодировкиТекста()
	Элементы.RequestBodyEncoding.СписокВыбора.Очистить();

	Виды = ВидыКодировокТелаЗапроса();
	Для Каждого КлючЗначение ИЗ Виды Цикл
		Элементы.RequestBodyEncoding.СписокВыбора.Добавить(КлючЗначение.Value);	
	EndDo;
	
КонецПроцедуры

&AtServer
Процедура ИнициализироватьФорму()
	MultipartBodySplitter = "X-TOOLS-UI-1C-BOUNDARY";
	
	ЗаполнитьСписокВыбораКодировкиТекста();
	
	Элементы.RequestBodyType.СписокВыбора.Очистить();
	ВидыТелаЗапроса = ВидыТелаЗапроса();
	Элементы.RequestBodyType.СписокВыбора.Добавить(TypesOfRequestBody.БезТела, "Без тела");
	Элементы.RequestBodyType.СписокВыбора.Добавить(TypesOfRequestBody.Строка);
	Элементы.RequestBodyType.СписокВыбора.Добавить(TypesOfRequestBody.ДвоичныеДанные, "Двоичные данные");
	Элементы.RequestBodyType.СписокВыбора.Добавить(TypesOfRequestBody.Файл);
	Элементы.RequestBodyType.СписокВыбора.Добавить(TypesOfRequestBody.МультипартФорм, "Multipart form");

	ВидыHTTPМетодов = ВидыHTTPМетодов();
	Элементы.HTTPRequest.СписокВыбора.Очистить();
	Для Каждого КлючЗначение Из ВидыHTTPМетодов Цикл
		Элементы.HTTPRequest.СписокВыбора.Добавить(КлючЗначение.Value);
	EndDo;
	
	ВидыСтроковогоСодержимогоТела = ТипыТекстовогоСодержимого();
	Элементы.RequestsTreeTypeOfStringContent.СписокВыбора.Очистить();
	Элементы.RequestsTreeTypeOfStringContent.СписокВыбора.Добавить("Нет");
	Для Каждого КлючЗначение Из ВидыСтроковогоСодержимогоТела Цикл
		Элементы.RequestsTreeTypeOfStringContent.СписокВыбора.Добавить(КлючЗначение.Ключ);
	EndDo;
	
	Элементы.RequestsTreeAuthenticationType.СписокВыбора.Очистить();
	
	ВидыАутентификации = ВидыАутентификации();
	Элементы.RequestsTreeAuthenticationType.СписокВыбора.Добавить(ВидыАутентификации.Нет);
	Элементы.RequestsTreeAuthenticationType.СписокВыбора.Добавить(ВидыАутентификации.Базовая, "Базовая(Логин,Пароль)");
	Элементы.RequestsTreeAuthenticationType.СписокВыбора.Добавить(ВидыАутентификации.BearerToken, "Bearer Токен");
	Если УИ_ОбщегоНазначенияКлиентСервер.ВерсияПлатформыНеМладше("8.3.7") Then
		Элементы.RequestsTreeAuthenticationType.СписокВыбора.Добавить(ВидыАутентификации.NTML, "NTML (аутентифкация ОС)");
	EndIf;
	
	Элементы.MultipartBodyRequestsTreeType.СписокВыбора.Очистить();
	
	ВидыЭлементовТелаМультипарт = MultypartItemsType();
	Элементы.MultipartBodyRequestsTreeType.СписокВыбора.Добавить(ВидыЭлементовТелаМультипарт.Строка);
	Элементы.MultipartBodyRequestsTreeType.СписокВыбора.Добавить(ВидыЭлементовТелаМультипарт.Файл);
		
	ИнициализироватьДеревоЗапросов();	

КонецПроцедуры


&AtServer
Процедура ИнициализироватьДеревоЗапросов()
	ЭлементыДерева = RequestsTree.ПолучитьЭлементы();
	Если ЭлементыДерева.Count() > 0 Then
		Return;
	EndIf;
	
	НоваяСтрока = ЭлементыДерева.Добавить();
	ИнициализироватьСтрокуДереваЗапросов(НоваяСтрока, ЭтотОбъект);
КонецПроцедуры


&НаКлиентеНаСервереБезКонтекста
Процедура ИнициализироватьСтрокуДереваЗапросов(RequestsTreeRow, Форма)
	RequestsTreeRow.HTTPRequest = Форма.ВидыHTTPМетодов.GET;
	RequestsTreeRow.BodyType = Форма.TypesOfRequestBody.БезТела;
	
	ВидыКодировокТелаЗапроса = ВидыКодировокТелаЗапроса();
	RequestsTreeRow.КодировкаТела = ВидыКодировокТелаЗапроса.Auto;
	
	RequestsTreeRow.Timeout = 30;
	RequestsTreeRow.ТипСтроковогоСодержимого = "Нет";
	
	Если Не ValueIsFilled(RequestsTreeRow.Name) Then
		RequestsTreeRow.Name = "Запрос" + Формат(RequestsTreeRow.ПолучитьИдентификатор(), "ЧГ=0;");
	EndIf;
	
	ВидыАутентификации = ВидыАутентификации();
	RequestsTreeRow.АутентификацияВид = ВидыАутентификации.Нет;
	
КонецПроцедуры



// Обновить заголовок формы.
&НаКлиенте
Процедура ОбновитьЗаголовок()

	Заголовок = НачальныйЗаголовок + ?(RequestsFileName <> "", ": " + RequestsFileName, "");

КонецПроцедуры


#EndRegion


&AtServer
Процедура ЗаполнитьДвоичныеДанныеТелаИзФайлаЗавершениеНаСервере(Адрес, RowID)
	ТекДанные = RequestsTree.FindByID(RowID);
	Если ТекДанные = Неопределено Then
		Return;
	EndIf;

	ДвоичныеДанные = ПолучитьИзВременногоХранилища(Адрес);

	ТекДанные.ТелоДвоичныеДанные = УИ_ОбщегоНазначения.ЗначениеХранилищаКонтейнераДвочныхДанных(ДвоичныеДанные);
	
	ТелоЗапросаДвоичныеДанныеСтрокой = ТекДанные.ТелоДвоичныеДанные.Представление;	
КонецПроцедуры

&НаКлиенте
Процедура ЗаполнитьДвоичныеДанныеТелаИзФайлаЗавершение(Результат, Адрес, ВыбранноеИмяФайла, ДополнительныеПараметры) Экспорт
	Если Не Результат Then
		Return;
	EndIf;

	ЗаполнитьДвоичныеДанныеТелаИзФайлаЗавершениеНаСервере(Адрес, ДополнительныеПараметры.ИдентификаторТекущейСтроки);

КонецПроцедуры

// Имя файла тела запроса начало выбора завершение.
// 
// Параметры:
//  ВыбранныеФайлы -Массив из Строка-Выбранные файлы
//  ДополнительныеПараметры - Структура:
//  * RowID -Число
&НаКлиенте
Процедура ИмяФайлаТелаЗапросаНачалоВыбораЗавершение(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт

	Если ВыбранныеФайлы = Неопределено Then
		Return;
	EndIf;

	Если ВыбранныеФайлы.Count() = 0 Then
		Return;
	EndIf;

	СтрокаЗапросов = RequestsTree.FindByID(ДополнительныеПараметры.RowID);
	Если СтрокаЗапросов = Неопределено Then
		Return;
	EndIf;

	СтрокаЗапросов.ИмяФайлаТела = ВыбранныеФайлы[0];
КонецПроцедуры

&AtServer
Процедура ЗаполнитьПоДаннымОтладки(АдресДанныхОтладки)
	ЭлементыДерева = RequestsTree.ПолучитьЭлементы();
	ЭлементыДерева.Очистить();
	
	НоваяСтрокаЗапроса = ЭлементыДерева.Добавить();
	ИнициализироватьСтрокуДереваЗапросов(НоваяСтрокаЗапроса, ЭтотОбъект);
	НоваяСтрокаЗапроса.Name = "Отладка";
	
	ДанныеДляОтладки = ПолучитьИзВременногоХранилища(АдресДанныхОтладки);

	НоваяСтрокаЗапроса.RequestURL = "";
	Если Не ValueIsFilled(ДанныеДляОтладки.Протокол) Then
		НоваяСтрокаЗапроса.RequestURL = "http";
	Иначе
		НоваяСтрокаЗапроса.RequestURL = ДанныеДляОтладки.Протокол;
	EndIf;

	НоваяСтрокаЗапроса.RequestURL = НоваяСтрокаЗапроса.RequestURL + "://" + ДанныеДляОтладки.АдресСервера;

	Если ValueIsFilled(ДанныеДляОтладки.Порт) Then
		ПортНестандартный = True;
		Если (Не ValueIsFilled(ДанныеДляОтладки.Протокол) Или ДанныеДляОтладки.Протокол = "http")
			 И ДанныеДляОтладки.Порт = 80 Then
			ПортНестандартный = Ложь;
		ElsIf ДанныеДляОтладки.Протокол = "https" И ДанныеДляОтладки.Порт = 443 Then
			ПортНестандартный = Ложь;
		EndIf;

		Если ПортНестандартный Then
			НоваяСтрокаЗапроса.RequestURL = НоваяСтрокаЗапроса.RequestURL + ":" + Формат(ДанныеДляОтладки.Порт, "ЧГ=0;");
		EndIf;
	EndIf;

	Если Не СтрНачинаетсяС(ДанныеДляОтладки.Запрос, "/") Then
		НоваяСтрокаЗапроса.RequestURL = НоваяСтрокаЗапроса.RequestURL + "/";
	EndIf;

	НоваяСтрокаЗапроса.RequestURL = НоваяСтрокаЗапроса.RequestURL + ДанныеДляОтладки.Запрос;

	РедактированиеЗаголовковТаблицей = True;
	Элементы.EditRequestHeadersPagesGroup.ТекущаяСтраница = Элементы.EditRequestHeadersPageGroupAsTable;

	Заголовки = ДанныеДляОтладки.Заголовки;

	//Удаляем неиспользуемые символы из строки заголовков
	ПозицияСимвола = НайтиНедопустимыеСимволыXML(Заголовки);
	Пока ПозицияСимвола > 0 Цикл
		Если ПозицияСимвола = 1 Then
			Заголовки = Сред(Заголовки, 2);
		ElsIf ПозицияСимвола = СтрДлина(Заголовки) Then
			Заголовки = Лев(Заголовки, СтрДлина(Заголовки) - 1);
		Иначе
			НовыеЗаголовки = Лев(Заголовки, ПозицияСимвола - 1) + Сред(Заголовки, ПозицияСимвола + 1);
			Заголовки = НовыеЗаголовки;
		EndIf;

		ПозицияСимвола = НайтиНедопустимыеСимволыXML(Заголовки);
	EndDo;

	ЗаполнитьТаблицуЗаголовковПоСтроке(Заголовки, НоваяСтрокаЗапроса.Заголовки);
	ЗаполнитьТелоЗапросаПоДаннымОтладки(НоваяСтрокаЗапроса, ДанныеДляОтладки);
	ЗаполнитьАутентификацияПоДаннымОтладки(НоваяСтрокаЗапроса, ДанныеДляОтладки);

	Если ValueIsFilled(ДанныеДляОтладки.ProxyServer) Then
		НоваяСтрокаЗапроса.UseProxy = True;

		НоваяСтрокаЗапроса.ProxyServer = ДанныеДляОтладки.ProxyServer;
		НоваяСтрокаЗапроса.ProxyPort = ДанныеДляОтладки.ProxyPort;
		НоваяСтрокаЗапроса.ProxyUser = ДанныеДляОтладки.ProxyUser;
		НоваяСтрокаЗапроса.ProxyPassword = ДанныеДляОтладки.ProxyPassword;
		НоваяСтрокаЗапроса.ProxyOSAuthentication = ДанныеДляОтладки.ИспользоватьАутентификациюОС;
	EndIf;

КонецПроцедуры

&AtServer
Процедура ЗаполнитьТелоЗапросаПоДаннымОтладки(НоваяСтрокаЗапроса, ДанныеДляОтладки)

	Если ДанныеДляОтладки.RequestBody <> Неопределено Then
		Если НайтиНедопустимыеСимволыXML(ДанныеДляОтладки.RequestBody) = 0 Then
			НоваяСтрокаЗапроса.BodyType = TypesOfRequestBody.Строка;
			НоваяСтрокаЗапроса.ТелоСтрокой = ДанныеДляОтладки.RequestBody;
			Return;
		EndIf;
	EndIf;

	Если ДанныеДляОтладки.Свойство("ДвоичныеДанныеТела") Then
		Если ТипЗнч(ДанныеДляОтладки.ДвоичныеДанныеТела) = Тип("ДвоичныеДанные") Then
			НоваяСтрокаЗапроса.BodyType = TypesOfRequestBody.ДвоичныеДанные;
			НоваяСтрокаЗапроса.ТелоДвоичныеДанные = УИ_ОбщегоНазначения.ЗначениеХранилищаКонтейнераДвочныхДанных(ДанныеДляОтладки.ДвоичныеДанныеТела);
			Return;
		EndIf;
	EndIf;
	Если ДанныеДляОтладки.Свойство("ИмяФайлаЗапроса") Then
		НоваяСтрокаЗапроса.BodyType = TypesOfRequestBody.Файл;
		НоваяСтрокаЗапроса.ИмяФайлаТела = ДанныеДляОтладки.ИмяФайлаЗапроса;
		Return;
	EndIf;

	НоваяСтрокаЗапроса.BodyType = TypesOfRequestBody.БезТела;
КонецПроцедуры

&AtServer
Процедура ЗаполнитьАутентификацияПоДаннымОтладки(НоваяСтрокаЗапроса, ДанныеДляОтладки)
	ВидыАутентификации = ВидыАутентификации();
	Если ДанныеДляОтладки.Свойство("СоединениеИспользоватьАутентификациюОС") Then
		Если ДанныеДляОтладки.СоединениеИспользоватьАутентификациюОС Then
			НоваяСтрокаЗапроса.АутентификацияВид = ВидыАутентификации.NTML;
			НоваяСтрокаЗапроса.АутентификацияИспользовать = True;
			Return;
		EndIf;
	EndIf;
	
	ИскомыйЗаголовок = "authorization";
	ЗначениеЗаголовкаАутентификации = "";
	
	Для Каждого Стр Из НоваяСтрокаЗапроса.Заголовки Цикл
		Если НРег(Стр.Ключ)	= ИскомыйЗаголовок Then
			ЗначениеЗаголовкаАутентификации = Стр.Value;
			Прервать;
		EndIf;	
	EndDo;
	
	Если не ValueIsFilled(ЗначениеЗаголовкаАутентификации) Then
		Return;
	EndIf;
	
	СтрокиЗначенияЗаголовка = СтрРазделить(ЗначениеЗаголовкаАутентификации, " ");
	Если СтрокиЗначенияЗаголовка.Count() <2 Then
		Return;
	EndIf;
	
	Схема = СтрокиЗначенияЗаголовка[0];
	Если НРег(Схема) = "basic" Then
		НоваяСтрокаЗапроса.АутентификацияВид = ВидыАутентификации.Базовая;
		НоваяСтрокаЗапроса.АутентификацияИспользовать = True;
		
		//@skip-check empty-except-statement
		Попытка
			СтрокаПользователя = ПолучитьСтрокуИзДвоичныхДанных(Base64Значение(СтрокиЗначенияЗаголовка[1]));
		Исключение
		КонецПопытки;
	
		МассивСтрокИмениПользователя = СтрРазделить(СтрокаПользователя, ":");
		НоваяСтрокаЗапроса.АутентификацияПользователь = МассивСтрокИмениПользователя[0];
		
		Если МассивСтрокИмениПользователя.Count() >1 Then
			МассивСтрокИмениПользователя.Удалить(0);
			НоваяСтрокаЗапроса.АутентификацияПароль = StrConcat(МассивСтрокИмениПользователя,":");
		EndIf;
	ElsIf НРег(Схема) = "bearer" Then 
		НоваяСтрокаЗапроса.АутентификацияВид = ВидыАутентификации.BearerToken;
		НоваяСтрокаЗапроса.АутентификацияИспользовать = True;
		НоваяСтрокаЗапроса.АутентификацияПароль = СтрокиЗначенияЗаголовка[1];
	EndIf;
КонецПроцедуры

// Редактировать тело запроса в редакторе JSONЗавершение.
// 
// Параметры:
//  Результат - Строка, Неопределено- Результат
//  ДополнительныеПараметры - Структура:
//  * ТекущаяСтрока - Число, Неопределено -
&НаКлиенте
Процедура РедактироватьТелоЗапросаВРедактореJSONЗавершение(Результат, ДополнительныеПараметры) Экспорт
	Если Результат = Неопределено Then
		Return;
	EndIf;

	Если ДополнительныеПараметры.ТекущаяСтрока = Неопределено Then
		Return;
	EndIf;
	
	СтрокаДерева = RequestsTree.FindByID(ДополнительныеПараметры.ТекущаяСтрока);
	Если СтрокаДерева = Неопределено Then
		Return;
	EndIf;

	СтрокаДерева.ТелоСтрокой=Результат;
	
	//ЗаполнитьСтруктуруJSONВДеревеЗапросов();
КонецПроцедуры


&AtServer
Function GeneratedHTTPRequestInitializationConnection(RequestsTreeRow, StructureURL)
	Если RequestsTreeRow.UseProxy Then
		ТекстНастройкаПрокси = StrTemplate("ПроксиПротокол = %1;
										 |ProxyServer = %2;
										 |ProxyPort = %3;
										 |ProxyUser = %4;
										 |ProxyPassword = %5;
										 |ProxyOSAuthentication = %6;
										 |
										 |НастройкаПрокси = Новый ИнтернетПрокси(True);
										 |НастройкаПрокси.Установить(ПроксиПротокол,
										 |							ProxyServer,
										 |							ProxyPort,
										 |							ProxyUser,
										 |							ProxyPassword,
										 |							ProxyOSAuthentication);",
										 UT_CodeGenerator.StringInCodeString(StructureURL.Схема),
										 UT_CodeGenerator.StringInCodeString(RequestsTreeRow.ProxyServer),
										 УИ_ГенераторКода.ЧислоВСтрокуКода(RequestsTreeRow.ProxyPort),
										 UT_CodeGenerator.StringInCodeString(RequestsTreeRow.ProxyUser),
										 UT_CodeGenerator.StringInCodeString(RequestsTreeRow.ProxyPassword),
										 УИ_ГенераторКода.БулевоВСтрокуКода(RequestsTreeRow.ProxyOSAuthentication));
	Иначе
		ТекстНастройкаПрокси = "НастройкаПрокси = " + УИ_ГенераторКода.НеопределеноВСтрокуКода() + ";";
	EndIf;	
	
	Порт = УИ_ГенераторКода.НеопределеноВСтрокуКода();
	Если ValueIsFilled(StructureURL.Порт) Then
		Порт = УИ_ГенераторКода.ЧислоВСтрокуКода(StructureURL.Порт);
	EndIf;	
		
	ИспользоватьNTMLАутентификацию = Неопределено;
	Если УИ_ОбщегоНазначенияКлиентСервер.ВерсияПлатформыНеМладше("8.3.7") Then
		Если RequestsTreeRow.АутентификацияИспользовать
			 И RequestsTreeRow.АутентификацияВид = ВидыАутентификации().NTML Then
			ИспользоватьNTMLАутентификацию = True;
		EndIf;
	EndIf;

	ЗащищенноеСоединение = УИ_ГенераторКода.НеопределеноВСтрокуКода();
	Если НРег(StructureURL.Схема) = "https" Then
		ЗащищенноеСоединение = "Новый ЗащищенноеСоединениеOpenSSL";
	EndIf;
	
	Если ИспользоватьNTMLАутентификацию = Неопределено Then
		ИспользоватьNTMLАутентификациюДляКода = УИ_ГенераторКода.НеопределеноВСтрокуКода();
		HTTPConnection = "Новый HTTPСоединение(Сервер, Порт, , , НастройкаПрокси,Timeout, ЗащищенноеСоединение)";
	Иначе
		ИспользоватьNTMLАутентификациюДляКода = УИ_ГенераторКода.БулевоВСтрокуКода(ИспользоватьNTMLАутентификацию);
		HTTPConnection = "Новый HTTPСоединение(Сервер, Порт, , , НастройкаПрокси,Timeout, ЗащищенноеСоединение, ИспользоватьNTMLАутентификацию)";
	EndIf;

	ТекстИнициализацииHTTPСоединения =StrTemplate("
												|Сервер = %1;
												|Порт = %2;
												|ИспользоватьNTMLАутентификацию = %3;
												|ЗащищенноеСоединение = %4;
												|Timeout = %5;
												|
												|HTTPConnection = %6;",
												UT_CodeGenerator.StringInCodeString(StructureURL.Сервер),
												Порт,
												ИспользоватьNTMLАутентификациюДляКода,
												ЗащищенноеСоединение,
												УИ_ГенераторКода.ЧислоВСтрокуКода(RequestsTreeRow.Timeout),
												HTTPConnection);
	
	Return ТекстНастройкаПрокси+ТекстИнициализацииHTTPСоединения;
EndFunction

&AtServer
Function GeneratedHTTPRequestInitializationCode(RequestsTreeRow, StructureURL)
	RowsToConcatenate = New Array;
	
	RowsToConcatenate.Add(StrTemplate("NewRequest = Новый HTTPЗапрос;
											|NewRequest.АдресРесурса = %1;
											|", UT_CodeGenerator.StringInCodeString(StructureURL.Путь)));
	
	
	
	Для Каждого СтрокаЗаголовка Из RequestsTreeRow.Заголовки Цикл
		Если Не СтрокаЗаголовка.Использование Then
			Continue;
		EndIf;

		RowsToConcatenate.Add(StrTemplate("NewRequest.Заголовки.Вставить(%1,%2);",
												UT_CodeGenerator.StringInCodeString(СтрокаЗаголовка.Ключ),
												UT_CodeGenerator.StringInCodeString(СтрокаЗаголовка.Value)));
	EndDo;

	ВидыАутентификации = ВидыАутентификации();
	Если RequestsTreeRow.АутентификацияИспользовать
		 И ValueIsFilled(RequestsTreeRow.АутентификацияВид)
		 И RequestsTreeRow.АутентификацияВид <> ВидыАутентификации.Нет Then

		Если RequestsTreeRow.АутентификацияВид = ВидыАутентификации.Базовая Then
			RowsToConcatenate.Add(StrTemplate("
													|//Аутентификация базовая
													|АутентификацияПользователь = %1;
													|АутентификацияПароль = %2;
													|NewRequest.Заголовки.Вставить(""Authorization"", ""Basic ""+Base64Строка(GetBinaryDataFromString(АутентификацияПользователь + "":""+ АутентификацияПароль)));",
													UT_CodeGenerator.StringInCodeString(RequestsTreeRow.АутентификацияПользователь),
													UT_CodeGenerator.StringInCodeString(RequestsTreeRow.АутентификацияПароль)));

		ElsIf RequestsTreeRow.АутентификацияВид = ВидыАутентификации.BearerToken Then

			Префикс = СокрЛП(RequestsTreeRow.АутентификацияПрефиксТокена);
			Если Не ValueIsFilled(Префикс) Then
				Префикс = "Bearer";
			EndIf;
			RowsToConcatenate.Add(StrTemplate("
													|//Аутентификация BearerToken
													|Токен = %1;
													|ПрефиксТокена = %2;
													|NewRequest.Заголовки.Вставить(""Authorization"", ПрефиксТокена +"" ""+Токен);",
													UT_CodeGenerator.StringInCodeString(RequestsTreeRow.АутентификацияПароль),
													UT_CodeGenerator.StringInCodeString(Префикс)));
		EndIf;

	EndIf;

	RowsToConcatenate.Add("
	|//Тело запроса");
	Если RequestsTreeRow.BodyType = TypesOfRequestBody.БезТела Then
		RowsToConcatenate.Add("//Без тела");
	ElsIf RequestsTreeRow.BodyType = TypesOfRequestBody.Строка Then
		Если RequestsTreeRow.UseBOM = 0 Then
			БОМ = "ИспользованиеByteOrderMark.Авто";
		ElsIf (RequestsTreeRow.UseBOM = 1) Then
			БОМ = "ИспользованиеByteOrderMark.Использовать";
		Иначе
			БОМ = "ИспользованиеByteOrderMark.НеИспользовать";
		EndIf;

		RowsToConcatenate.Add(StrTemplate("//Тело строкой
												|RequestBody = %1;
												|ИспользованиеБОМ = %2;",
												UT_CodeGenerator.StringInCodeString(RequestsTreeRow.ТелоСтрокой),
												БОМ));

		Если RequestsTreeRow.КодировкаТела = "Auto" Then
			RowsToConcatenate.Add("NewRequest.УстановитьТелоИзСтроки(RequestBody, , ИспользованиеБОМ);");
		Иначе
			Попытка
				//@skip-check module-unused-local-variable
				КодировкаТела = TextEncoding[RequestsTreeRow.КодировкаТела];
				RowsToConcatenate.Add(StrTemplate("КодировкаТела = TextEncoding.%1;",
														RequestsTreeRow.КодировкаТела));
			Исключение
				RowsToConcatenate.Add(StrTemplate("КодировкаТела = %1;",
														UT_CodeGenerator.StringInCodeString(RequestsTreeRow.КодировкаТела)));

			КонецПопытки;
			RowsToConcatenate.Add("NewRequest.УстановитьТелоИзСтроки(RequestBody, КодировкаТела, ИспользованиеБОМ);");

		EndIf;
	ElsIf RequestsTreeRow.BodyType = TypesOfRequestBody.ДвоичныеДанные Then
		Если RequestsTreeRow.ТелоДвоичныеДанные <> Неопределено Then
			ДвоичныеДанныеТела = УИ_ОбщегоНазначения.ЗначениеИзХранилищаКонтейнераДвоичныхДанных(RequestsTreeRow.ТелоДвоичныеДанные);
			Если ТипЗнч(ДвоичныеДанныеТела) = Тип("ДвоичныеДанные") Then
				СтрокаДвоичныхДанных = Base64Строка(ДвоичныеДанныеТела);
				RowsToConcatenate.Add(StrTemplate("//Тело ДвоичныеДанные
														|RequestBody = Base64Значение(%1);
														|NewRequest.SetBodyFromBinaryData(RequestBody);",
														UT_CodeGenerator.StringInCodeString(СтрокаДвоичныхДанных)));

			EndIf;
		EndIf;
	ElsIf RequestsTreeRow.BodyType = TypesOfRequestBody.Файл Then
		RowsToConcatenate.Add(StrTemplate("// File body
										|RequestBody = %1;
										|NewRequest.SetBodyFileName(RequestBody);",
										UT_CodeGenerator.StringInCodeString(RequestsTreeRow.ИмяФайлаТела)));
	ElsIf RequestsTreeRow.BodyType = TypesOfRequestBody.МультипартФорм Then 
		MultypartItemsType = MultypartItemsType();
		
		RowsToConcatenate.Add("//Body Multypartdata
		|MultipartBodySplitter = ""---""+StrReplace(String(New UUID), ""-"", """")+""---"";
		|
		|FilesToCombine = New Array;");	

		FilesExist = Ложь;
		For RowIndex = 0 To RequestsTreeRow.MultipartBody.Count() - 1 Do
			MultypartItemRow = RequestsTreeRow.MultipartBody[RowIndex];
			If Not MultypartItemRow.Using Then
				Continue;
			EndIf;
			
			If MultypartItemRow.Type = MultypartItemsType.String Then
				FilesExist = True;

				RowsToConcatenate.Add(StrTemplate("
												|CurrentParameterName = %1;
												|CurrentParameterValue = %2;
												|
												|StreamRecord = New MemoryStream;
												|
												|InputFile = New TextWriter(StreamRecord, TextEncoding.ANSI, Chars.LF);
												|InputFile.WriteLine("""");
												|InputFile.WriteLine(""--"" + MultipartBodySplitter);
												|InputFile.WriteLine(""Content-Disposition: form-data;name=""""""+CurrentParameterName+"""""""");
												|InputFile.WriteLine("""");
												|InputFile.Close();
												|FilesToCombine.Add(StreamRecord.CloseAndGetBinaryData());
												|
												|FilesToCombine.Add(GetBinaryDataFromString(CurrentParameterValue));",
												UT_CodeGenerator.StringInCodeString(MultypartItemRow.Name),
												UT_CodeGenerator.StringInCodeString(MultypartItemRow.Value)));

			ElsIf MultypartItemRow.Type = MultypartItemsType.File Then
				If Not ValueIsFilled(MultypartItemRow.Value) Then
					Continue;
				EndIf;

				FilesExist = True;

				RowsToConcatenate.Add(StrTemplate("
												|CurrentParameterName = %1;
												|CurrentFileName = %2;
												|
												|File = New File(CurrentFileName);
												|FileBinaryData = New BinaryData(CurrentFileName);
												|
												|StreamRecord = New MemoryStream;
												|
												|InputFile = New TextWriter(StreamRecord, TextEncoding.ANSI, Chars.LF);
												|InputFile.WriteLine("""");
												|InputFile.WriteLine(""--"" + MultipartBodySplitter);
												|InputFile.WriteLine(""Content-Disposition: form-data;name=""""""
												|													+ CurrentParameterName 
												|													+ """""";filename="""""" 
												|													+ File.Name+ """""""");
												|InputFile.WriteLine(""Content-Type: application/octet-stream"");  
												|InputFile.WriteLine("""");
												|InputFile.Close();
												|FilesToCombine.Add(StreamRecord.CloseAndGetBinaryData());
												|
												|FilesToCombine.Add(FileBinaryData);",
												UT_CodeGenerator.StringInCodeString(MultypartItemRow.Name),
												UT_CodeGenerator.StringInCodeString(MultypartItemRow.Value)));
			EndIf;

		EndDo;
		
		If FilesExist Then
			RowsToConcatenate.Add("
			|StreamRecord = New MemoryStream;
			|InputFile = New TextWriter(StreamRecord, TextEncoding.ANSI, Chars.LF);
			|InputFile.WriteLine("""");
			|InputFile.WriteLine(""--"" + MultipartBodySplitter + ""--"");
			|InputFile.Close();
			|
			|FilesToCombine.Add(StreamRecord.CloseAndGetBinaryData());
			|
			|FinalBD = ConcatBinaryData(FilesToCombine);
			|
			|NewRequest.SetBodyFromBinaryData(FinalBD);
			|
			|NewRequest.Headers.Insert(""Content-Type"", ""multipart/form-data; boundary=""+MultipartBodySplitter);
			|NewRequest.Headers.Insert(""Content-Length"", XMLString(FinalBD.Size()));
			|");
		EndIf;

	EndIf;

	Return StrConcat(RowsToConcatenate, Chars.LF);
	

	
EndFunction

&AtServer
Function GeneratedRequestExecutionCode(RequestsTreeRow)
	
	
	Return StrTemplate("RequestType = %1;
					  |
					  |StartExecution = CurrentUniversalDateInMilliseconds();
					  |
					  |HTTPResponse = HTTPConnection.CallHTTPMethod(RequestType, NewRequest);
					  |FinishExecution = CurrentUniversalDateInMilliseconds();
					  |
					  |Duration = FinishExecution - StartExecution;
					  |
					  |StatusCode = HTTPResponse.StatusCode;
					  |ResponseBodyString = HTTPResponse.GetBodyAsString();
					  |ResponseBodyBinaryData = HTTPResponse.GetBodyAsBinaryData();
					  |", UT_CodeGenerator.StringInCodeString(RequestsTreeRow.HTTPRequest));
EndFunction

Function GeneratedExecutionCodeAtServer(RowID)
	RequestsTreeRow = RequestsTree.FindByID(RowID);
	StructureURL = UT_HTTPConnector.ParseURL(RequestsTreeRow.RequestURL);
	
	
	ExecuteText = UT_CodeGenerator.StandardGeneratedCodeHeader("HTTP Request Console",
															RequestsFileName,
															RequestsTreeRow.Name);

	ExecuteText = ExecuteText
					  + GeneratedHTTPRequestInitializationConnection(RequestsTreeRow, StructureURL)
					  + Chars.LF
					  + GeneratedHTTPRequestInitializationCode(RequestsTreeRow, StructureURL)
					  + Chars.LF
					  + GeneratedRequestExecutionCode(RequestsTreeRow);
								
	Return ExecuteText;
EndFunction



#EndRegion

