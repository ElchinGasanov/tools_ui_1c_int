
///////////////////////////////////////////////////////////////////////////////
// PRIVATE

&AtServer
Function DataProcessorID()
	DataProcessorObject = FormAttributeToValue("Object");
	Return DataProcessorObject.Metadata().FullName();
EndFunction

// Displays error message and sets Cancel to True.
// If at client or at server, displays message in message window.
// If external connection, raises exception.
//
// Parameters:
//  MessageText - String - message text.
//  Cancel      - Boolean, (optional) cancel flag.
//
&AtServerNoContext
Procedure mErrorMessage(MessageText, Cancel = False, Title = "") Export

	InternalMessageBegin    = Find(MessageText, "{");
	InternalMessageEnd = Find(MessageText, "}:");
	If InternalMessageEnd > 0 And InternalMessageBegin > 0 Then
		MessageText = Left(MessageText, (InternalMessageBegin - 1)) + Mid(MessageText,
			(InternalMessageEnd + 2));
	EndIf;

	Cancel = True;

	If ValueIsFilled(Title) Then
		Message(Title);
		Title = "";
	EndIf;

	Message(MessageText, MessageStatus.Important);

EndProcedure

// Splits the string into several strings by the specified separator. The separator can be any length.
// If space is used as a separator, adjacent spaces are treated as one separator, 
// leading and trailing spaces of the Str parameter are ignored.
// 
// Example:
//		mSplitStringIntoSubstringsArray(",qu,,,mu", ",")
//			- returns an array of five items, three of which are empty strings;
//		mSplitStringIntoSubstringsArray(" qu   mu", " ")
//			- returns an array of two items: "qu", "mu".
//
//	Parameters:
//		Str - String - a delimited text.
//		Separator - String - a text separator, "," by default.
//
//
//	Return value:
//		Array - an array of strings.
//
&AtServer
Function mSplitStringIntoSubstringsArray(Val Str, Separator = ",")

	StringArray = New Array;
	If Separator = " " Then
		Str = TrimAll(Str);
		While 1 = 1 Do
			Pos = Find(Str, Separator);
			If Pos = 0 Then
				StringArray.Add(Str);
				Return StringArray;
			EndIf;
			StringArray.Add(Left(Str, Pos - 1));
			Str = TrimL(Mid(Str, Pos));
		EndDo;
	Else
		SeparatorLength = StrLen(Separator);
		While 1 = 1 Do
			Pos = Find(Str, Separator);
			If Pos = 0 Then
				StringArray.Add(Str);
				Return StringArray;
			EndIf;
			StringArray.Add(Left(Str, Pos - 1));
			Str = Mid(Str, Pos + SeparatorLength);
		EndDo;
	EndIf;

EndFunction

// Function adjusts a string presentation of number to its value.
//
// Parameters:
//  Presentation - String - a number presentation.
//  TypeDescription - TypeDescription - a description of number type to adjust to.
//  Comment - String - an error description.
//
// Return value:
//  Number - Adjusted value.
//
&AtServer
Function mAdjustToNumber(Presentation, Val TypeDescription = Undefined, Comment = "")

	If TypeDescription = Undefined Then
		TypeDescription = New TypeDescription("Number");
	EndIf;

	PresentationLower = Lower(Presentation);
	If PresentationLower = "yes" Or PresentationLower = "True" Or PresentationLower = "enabled" Then
		Return 1;
	ElsIf PresentationLower = "no" Or PresentationLower = "False" Or PresentationLower = "disabled" Then
		Return 0;
	EndIf;

	Result = StrReplace(Presentation, " ", "");
	Try
		Result = Number(Result);
	Except
		Comment = NStr("ru = 'Неправильный формат числа'; en = 'Incorrect number format'");
		Return 0;
	EndTry;

	Result1 = TypeDescription.AdjustValue(Result);

	If Not Result1 = Result Then
		Comment = NStr("ru = 'Недопустимое числовое значение'; en = 'Invalid number value'");
	EndIf;

	Return Result1;

EndFunction // mAdjustToNumber()

// Function приводит строковое представление даты к его значению
//
// Параметры:
//  Представление - Представление числа
//  TypeDescription - Допустимое описание типов значения типа дата
//
// Возвращаемое значение:
//  Значение типа дата
//
&AtServer
Function мПривестиКДате(Представление, ТипРеквизита, Примечание = "")

	Результат = ТипРеквизита.ПривестиЗначение(Представление);
	Если Результат = '00010101' Тогда

		МассивЧастей = ПолучитьЧастиПредставленияДаты(Представление);
		Если ТипРеквизита.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Время Тогда

			Try

				Если МассивЧастей.Количество() = 3 Тогда
					Результат = Дата(1, 1, 1, МассивЧастей[0], МассивЧастей[1], МассивЧастей[2]);
				ElsIf МассивЧастей.Количество() = 6 Тогда
					Результат = Дата(1, 1, 1, МассивЧастей[3], МассивЧастей[4], МассивЧастей[5]);
				EndIf;

			Исключение
				Примечание = "Неправильный формат даты";
			EndTry;

		ElsIf МассивЧастей.Количество() = 3 Или МассивЧастей.Количество() = 6 Тогда

			Если МассивЧастей[0] >= 1000 Тогда
				Временно = МассивЧастей[0];
				МассивЧастей[0] = МассивЧастей[2];
				МассивЧастей[2] = Временно;
			EndIf;

			Если МассивЧастей[2] < 100 Тогда
				МассивЧастей[2] = МассивЧастей[2] + ?(МассивЧастей[2] < 30, 2000, 1900);
			EndIf;

			Try
				Если МассивЧастей.Количество() = 3 Или ТипРеквизита.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Дата Тогда
					Результат = Дата(МассивЧастей[2], МассивЧастей[1], МассивЧастей[0]);
				Иначе
					Результат = Дата(МассивЧастей[2], МассивЧастей[1], МассивЧастей[0], МассивЧастей[3],
						МассивЧастей[4], МассивЧастей[5]);
				EndIf;
			Исключение
				Примечание = "Неправильный формат даты";
			EndTry;

		EndIf;

	EndIf;

	Return Результат;

EndFunction

// Function возвращает части представления даты
//
// Параметры:
//  Представление - Представление даты
//
// Возвращаемое значение:
//  массив частей даты
//
&AtServer
Function ПолучитьЧастиПредставленияДаты(Знач Представление)

	МассивЧастей = Новый Массив;
	НачалоЦифры = 0;
	Для к = 1 По СтрДлина(Представление) Цикл

		Символ = Сред(Представление, к, 1);
		ЭтоЦифра = Символ >= "0" И Символ <= "9";

		Если ЭтоЦифра Тогда

			Если НачалоЦифры = 0 Тогда
				НачалоЦифры = к;
			EndIf;

		Иначе

			Если Не НачалоЦифры = 0 Тогда
				МассивЧастей.Добавить(Число(Сред(Представление, НачалоЦифры, к - НачалоЦифры)));
			EndIf;

			НачалоЦифры = 0;
		EndIf;

	EndDo;

	Если Не НачалоЦифры = 0 Тогда
		МассивЧастей.Добавить(Число(Сред(Представление, НачалоЦифры)));
	EndIf;

	Return МассивЧастей;
EndFunction // ()

// Function возвращает менеджер по типу значения
//
// Параметры:
//  ТипЗначения - Тип значения, по которому нужна вернуть менеджер
//
// Возвращаемое значение:
//  менеджер
&AtServer
Function ПолучитьМенеджераПоТипу(ТипЗначения) Экспорт

	Если Не ТипЗначения = Undefined Тогда
		МенеджерыОбъектовМетаданных = Новый Структура("Справочники, Перечисления, Документы, ПланыВидовХарактеристик, ПланыСчетов, ПланыВидовРасчета, БизнесПроцессы, Задачи",
			Справочники, Перечисления, Документы, ПланыВидовХарактеристик, ПланыСчетов, ПланыВидовРасчета,
			БизнесПроцессы, Задачи);
		Для Каждого МенеджерОбъектаМетаданных Из МенеджерыОбъектовМетаданных Цикл
			Если МенеджерОбъектаМетаданных.Значение.ТипВсеСсылки().СодержитТип(ТипЗначения) Тогда
				Менеджер = МенеджерОбъектаМетаданных.Значение[Метаданные.НайтиПоТипу(ТипЗначения).Имя];
				Прервать;
			EndIf;
		EndDo;
		Return Менеджер;
	Иначе
		Return Undefined;
	EndIf;

EndFunction

&AtServer
Function ПолучитьОписаниеТипа(ОписаниеТиповРеквизита) Экспорт

	ОписаниеТипов = "";

	Для Каждого Тип Из ОписаниеТиповРеквизита.Типы() Цикл
		МетаданныеТипа = Метаданные.НайтиПоТипу(Тип);
		Если Не МетаданныеТипа = Undefined Тогда
			ОписаниеТипа = МетаданныеТипа.ПолноеИмя();
		ElsIf Тип = Тип("Строка") Тогда

			ОписаниеТипа = "Строка";
			Если ОписаниеТиповРеквизита.КвалификаторыСтроки.Длина Тогда
				ОписаниеТипа = ОписаниеТипа + ", " + ОписаниеТиповРеквизита.КвалификаторыСтроки.Длина;
				Если ОписаниеТиповРеквизита.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Фиксированная Тогда
					ОписаниеТипа = ОписаниеТипа + ", " + ДопустимаяДлина.Фиксированная;
				EndIf;
			EndIf;

		ElsIf Тип = Тип("Число") Тогда
			ОписаниеТипа = "Число" + ", " + ОписаниеТиповРеквизита.КвалификаторыЧисла.Разрядность + ", "
				+ ОписаниеТиповРеквизита.КвалификаторыЧисла.РазрядностьДробнойЧасти + ?(
				ОписаниеТиповРеквизита.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Неотрицательный,
				", Неотрицательный", "");
		ElsIf Тип = Тип("Дата") Тогда
			ОписаниеТипа = "" + ОписаниеТиповРеквизита.КвалификаторыДаты.ЧастиДаты;
		ElsIf Тип = Тип("Булево") Тогда
			ОписаниеТипа = "Булево";
		Иначе
			Продолжить;
		EndIf;

		ОписаниеТипов = ?(ПустаяСтрока(ОписаниеТипов), "", ОписаниеТипов + Символы.ПС) + ОписаниеТипа;

	EndDo;

	Return ОписаниеТипов;

EndFunction // ПолучитьОписаниеТипа()

////////////////////////////////////////////////////////////////////////////////
//

&AtServer
Function мВосстановитьЗначение(Имя)
	Return ХранилищеНастроекДанныхФорм.Загрузить(DataProcessorID(), Имя);
EndFunction

&AtServer
Procedure мСохранитьЗначение(Имя, Знач Значение)

	Если ТипЗнч(Значение) = Тип("ДанныеФормыКоллекция") Тогда

		Значение = ДанныеФормыВЗначение(Значение, Тип("ТаблицаЗначений"));

	EndIf;

	ХранилищеНастроекДанныхФорм.Сохранить(DataProcessorID(), Имя, Значение);

EndProcedure

// Function возвращает настройку, сохраненную в списке сохраненных настроек
//
// Параметры:
//  Нет
//
// Возвращаемое значение:
//  табличный документ - настройки загружаемых реквизитов
//
&AtServer
Function ПолучитьНастройкуПоУмолчанию(СписокНастроек)

	МетаданныеИсточника = ПолучитьМетаданныеИсточника();

	Если МетаданныеИсточника = Undefined Тогда
		Return Undefined;
	EndIf;
	//ТЗ = FormAttributeToValue("СписокСохраненныхНастроек");
	Для Каждого СтрокаСписка Из СписокНастроек Цикл
		Если СтрокаСписка.Check Тогда
			Return СтрокаСписка.Значение;
		EndIf;
	EndDo;
	Return Undefined;

EndFunction // ()

////////////////////////////////////////////////////////////////////////////////
//

// Procedure заполняет список выбора элемента управления "SourceTabularSection"
//
&AtServer
Procedure УстановитьСписокТабличныхЧастей()

	СписокВыбора = Элементы.SourceTabularSection.СписокВыбора;
	СписокВыбора.Очистить();
	Если Object.SourceRef = Undefined Тогда
		Return;
	EndIf;
	Для Каждого ТабличнаяЧасть Из Object.SourceRef.Метаданные().ТабличныеЧасти Цикл
		СписокВыбора.Добавить(ТабличнаяЧасть.Имя, ТабличнаяЧасть.Представление());
	EndDo;
	Если Не ПустаяСтрока(Object.SourceTabularSection) И СписокВыбора.НайтиПоЗначению(Object.SourceTabularSection)
		= Undefined Тогда
		Object.SourceTabularSection = "";
	EndIf;

EndProcedure // ()

// Procedure формирует структуру колонок загружаемых реквизитов из табличной части "ImportedAttributesTable"
//
// Параметры:
//  нет
//
&AtServer
Procedure СформироватьСтруктуруКолонок()

	НомерКолонки = 1;
	Колонки = Новый Структура;

	ТЗ = FormAttributeToValue("ImportedAttributesTable");

	ВремКолонки = ТЗ.СкопироватьКолонки();
	Для Каждого ЗагружаемыйРеквизит Из ТЗ Цикл
		Колонка = Новый Структура;
		Для Каждого КолонкаЗагружаемыхРеквизитов Из ВремКолонки.Колонки Цикл
			Если Не Object.ManualSpreadsheetDocumentColumnsNumeration И КолонкаЗагружаемыхРеквизитов.Имя
				= "ColumnNumber" Тогда
				Если ЗагружаемыйРеквизит.Check Тогда
					Колонка.Вставить("ColumnNumber", НомерКолонки);
					НомерКолонки = НомерКолонки + 1;
				Иначе
					Колонка.Вставить("ColumnNumber", 0);
				EndIf;
			Иначе
				Колонка.Вставить(КолонкаЗагружаемыхРеквизитов.Имя,
					ЗагружаемыйРеквизит[КолонкаЗагружаемыхРеквизитов.Имя]);
			EndIf;

		EndDo;

		Колонки.Вставить(Колонка.ИмяРеквизита, Колонка);

	EndDo;

	Object.AdditionalProperties.Вставить("Колонки", Колонки);

EndProcedure // ()

// Procedure формирует шапку табличного документа, в соответствии с таблицей загружаемых реквизитов
//
// Параметры:
//  SpreadsheetDocument - SpreadsheetDocument, у которого необходимо сформировать шапку
//
&AtServer
Procedure СформироватьШапкуТабличногоДокумента(ТабличныйДокумент)

	Линия = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);

	ТЗ = FormAttributeToValue("ImportedAttributesTable");

	Таблица = ТЗ.Скопировать();
	Таблица.Сортировать("ColumnNumber");

	Колонки = Object.AdditionalProperties.Колонки;

	Для Каждого КлючИЗначение Из Колонки Цикл
		ЗагружаемыйРеквизит = КлючИЗначение.Значение;
		НомерКолонки = ЗагружаемыйРеквизит.ColumnNumber;
		Если Не ЗагружаемыйРеквизит.Check Или НомерКолонки = 0 Тогда
			Продолжить;
		EndIf;

		Если ЗагружаемыйРеквизит.ColumnWidth = 0 Тогда

			ШиринаКолонки = 40;
			Если ЗагружаемыйРеквизит.TypeDescription.Типы().Количество() = 1 Тогда
				ПервыйТип = ЗагружаемыйРеквизит.TypeDescription.Типы()[0];
				Если ПервыйТип = Тип("Строка") Тогда
					Если ЗагружаемыйРеквизит.TypeDescription.КвалификаторыСтроки.Длина = 0 Тогда
						ШиринаКолонки = 80;
					Иначе
						ШиринаКолонки = Мин(Макс(ЗагружаемыйРеквизит.TypeDescription.КвалификаторыСтроки.Длина, 10), 80);
					EndIf;
				ElsIf ПервыйТип = Тип("Число") Тогда
					ШиринаКолонки = Макс(ЗагружаемыйРеквизит.TypeDescription.КвалификаторыЧисла.Разрядность, 10);
				ElsIf ПервыйТип = Тип("Булево") Тогда
					ШиринаКолонки = 10;
				EndIf;
			EndIf;
		Иначе
			ШиринаКолонки = ЗагружаемыйРеквизит.ColumnWidth;
		EndIf;
		Область = ТабличныйДокумент.Область("R1C" + НомерКолонки);
		БылТекст = Не ПустаяСтрока(Область.Текст);
		Область.Текст       = ?(БылТекст, Область.Текст + Символы.ПС, "") + ЗагружаемыйРеквизит.AttributePresentation;
		Область.Расшифровка = ЗагружаемыйРеквизит.AttributeName;
		Область.ЦветФона = ЦветаСтиля.ЦветФонаФормы;
		Область.Обвести(Линия, Линия, Линия, Линия);

		ОбластьКолонки = ТабличныйДокумент.Область("C" + НомерКолонки);
		ОбластьКолонки.ColumnWidth = ?(БылТекст, Макс(ОбластьКолонки.ШиринаКолонки, ШиринаКолонки), ШиринаКолонки);

	EndDo;

EndProcedure // СформироватьШапкуТабличногоДокумента()

// Function возвращает метаданные источника данных
//
// Параметры:
//  нет
//
// Возвращаемое значение:
//  Объект метаданных
//
&AtServer
Function ПолучитьМетаданныеИсточника()

	Если Object.ImportMode = 0 Тогда
		Если Не ПустаяСтрока(Object.CatalogObjectType) Тогда
			Return Метаданные.Справочники.Найти(Object.CatalogObjectType);
		EndIf;
	ElsIf Object.ImportMode = 1 Тогда
		Если Не Object.SourceRef = Undefined И Не Object.SourceTabularSection = Undefined Тогда
			Return Object.SourceRef.Метаданные().ТабличныеЧасти.Найти(Object.SourceTabularSection);
		EndIf;
	ElsIf Object.ImportMode = 2 Тогда
		Если Не ПустаяСтрока(Object.RegisterTypeName) Тогда
			Return Метаданные.РегистрыСведений.Найти(Object.RegisterTypeName);
		EndIf;
	EndIf;

	Return Undefined;

EndFunction // ()

&AtServer
Function ЕстьВыбранныеМетаданные()

	Return Не ПолучитьМетаданныеИсточника() = Undefined;

EndFunction // ЕстьВыбранныеМетаданные()

&AtServer
Function ПолучитьТекстВопросаИсточника()

	МетаданныеИсточника = ПолучитьМетаданныеИсточника();

	Ошибка = "";
	ТекстВопросаИсточника = "";

	Если Object.ImportMode = 0 Тогда
		ТекстВопросаИсточника = " элементов в справочник: """ + МетаданныеИсточника.Представление() + """";

	ElsIf Object.ImportMode = 1 Тогда

		Если Object.SourceRef.Пустая() Тогда
			Ошибка = "Не выбрана ссылка";
		Иначе
			ОбъектИсточника = Object.SourceRef.ПолучитьОбъект();
			ТекстВопросаИсточника = " строк в табличную часть: """ + МетаданныеИсточника.Представление() + """";
		EndIf;

	ElsIf Object.ImportMode = 2 Тогда

		ТекстВопросаИсточника = " записей в регистр сведений: """ + МетаданныеИсточника.Представление() + """";

	EndIf;

	Return Новый Структура("Ошибка, ТекстВопроса", Ошибка, ТекстВопросаИсточника);

EndFunction

&AtServer
Function ЗагрузитьДанныеСервер()

	ЗаписыватьОбъект = True;
	ВозможноСозданиеГруппы = False;

	СформироватьСтруктуруКолонок();

	МетаданныеИсточника = ПолучитьМетаданныеИсточника();

	Колонки = Object.AdditionalProperties.Колонки;

	Если Object.ImportMode = 0 Тогда
		Источник = Справочники[Object.CatalogObjectType].ПустаяСсылка();
	ElsIf Object.ImportMode = 1 Тогда
		ОбъектИсточника = Object.SourceRef.ПолучитьОбъект();
		Источник = ОбъектИсточника[Object.SourceTabularSection];
	EndIf;

	ТекстВопросаИсточника = ПолучитьТекстВопросаИсточника().ТекстВопроса;
	КоличествоЭлементов = SpreadsheetDocument.ВысотаТаблицы - Object.SpreadsheetDocumentFirstDataRow + 1;

	Запрос = Undefined;
	Если Object.ImportMode = 0 Тогда

		ВозможноСозданиеГруппы = ВозможноСозданиеГруппы(МетаданныеИсточника);
		СтрокиПоиска = ImportedAttributesTable.НайтиСтроки(Новый Структура("SearchField,Check", True, True));
		Если Не СтрокиПоиска.Количество() = 0 Тогда

			ТекстЗапроса = "Выбрать Первые 1
						   |Справочник.Ссылка КАК Ссылка
						   |Из Справочник." + МетаданныеИсточника.Имя + " КАК Справочник
																		|Где";

			Для Каждого СтрокаПоиска Из СтрокиПоиска Цикл
				ТекстЗапроса = ТекстЗапроса + "
											  |Справочник." + СтрокаПоиска.AttributeName + " = &"
					+ СтрокаПоиска.AttributeName + "
												  |И";

			EndDo;

			ТекстЗапроса = Лев(ТекстЗапроса, СтрДлина(ТекстЗапроса) - 2);
			Запрос = Новый Запрос(ТекстЗапроса);
		EndIf;
	ElsIf Object.ImportMode = 1 Тогда

		Источник.Очистить();
	ElsIf Object.ImportMode = 2 Тогда

		ИзмеренияРегистра = Новый Структура;
		Для Каждого Колонка Из Колонки Цикл
			Если Колонка.Значение.PossibleSearchField Тогда
				ИзмеренияРегистра.Вставить(Колонка.Ключ, Колонка.Значение);
			EndIf;
		EndDo;
	EndIf;
	Сообщить("Выполняется загрузка" + ТекстВопросаИсточника, СтатусСообщения.Информация);
	Сообщить("Всего: " + КоличествоЭлементов, СтатусСообщения.Информация);
	Сообщить("---------------------------------------------", СтатусСообщения.БезСтатуса);
	НомерТекущейСтроки = 0;
	Загружено = 0;
	Для К = Object.SpreadsheetDocumentFirstDataRow По SpreadsheetDocument.ВысотаТаблицы Цикл
		НомерТекущейСтроки = НомерТекущейСтроки + 1;
		ТекстыЯчеек = Undefined;
		Отказ = False;
		ТекущаяСтрока = КонтрольЗаполненияСтроки(SpreadsheetDocument, К, ТекстыЯчеек);
		Если Object.ImportMode = 0 Тогда

			ЗагружаемыйОбъект = Undefined;
			Если Не Запрос = Undefined Тогда
				СтрокаОшибок = "";
				Для Каждого СтрокаПоиска Из СтрокиПоиска Цикл

					ЗначениеРеквизита = Undefined;

					ТекущаяСтрока.Свойство(СтрокаПоиска.AttributeName, ЗначениеРеквизита);
					Если ПустаяСтрока(ЗначениеРеквизита) Тогда
						СтрокаОшибок = ?(ПустаяСтрока(СтрокаОшибок), "", СтрокаОшибок + ", ")
							+ СтрокаПоиска.AttributePresentation;
					Иначе
						Запрос.УстановитьПараметр(СтрокаПоиска.AttributeName, ТекущаяСтрока[СтрокаПоиска.AttributeName]);
					EndIf;

				EndDo;

				Если Не ПустаяСтрока(СтрокаОшибок) Тогда
					Сообщить("Строка " + НомерТекущейСтроки
						+ " не может быть записана.Не указано значение ключевых реквизитов: " + СтрокаОшибок,
						СтатусСообщения.Важное);
					Продолжить;
				EndIf;

				Выборка = Запрос.Выполнить().Выбрать();
				Если Выборка.Следующий() Тогда
					ЗагружаемыйОбъект = Выборка.Ссылка.ПолучитьОбъект();
				EndIf;

			EndIf;

			ОбъектНайден = Не ЗагружаемыйОбъект = Undefined;
			Если Не ОбъектНайден Тогда
				Если Object.DontCreateNewItems Тогда
					Продолжить;
				ElsIf ВозможноСозданиеГруппы И ТекущаяСтрока.ЭтоГруппа Тогда
					ЗагружаемыйОбъект = Справочники[МетаданныеИсточника.Имя].СоздатьГруппу();
				Иначе
					ЗагружаемыйОбъект = Справочники[МетаданныеИсточника.Имя].СоздатьЭлемент();
				EndIf;

			EndIf;
		ElsIf Object.ImportMode = 1 Тогда
			ЗагружаемыйОбъект = Источник.Добавить();
			ОбъектНайден = False;
		ElsIf Object.ImportMode = 2 Тогда
			ЗагружаемыйОбъект = РегистрыСведений[МетаданныеИсточника.Имя].СоздатьМенеджерЗаписи();
			Для Каждого КлючИЗначение Из ТекущаяСтрока Цикл

				Если ИзмеренияРегистра.Свойство(КлючИЗначение.Ключ) Тогда
					ЗагружаемыйОбъект[КлючИЗначение.Ключ] = КлючИЗначение.Значение;
				EndIf;

			EndDo;

			Если Не Object.ReplaceExistingRecords Тогда
				ЗагружаемыйОбъект.Прочитать();
				ОбъектНайден = ЗагружаемыйОбъект.Выбран();
			Иначе
				ОбъектНайден = False;
			EndIf;

		EndIf;

		Для Каждого КлючИЗначение Из ТекущаяСтрока Цикл
			
			Если КлючИЗначение.Ключ = "ЭтоГруппа" Тогда
				Продолжить;	
			EndIf; 

			Если Не ОбъектНайден Или Колонки[КлючИЗначение.Ключ].Check Тогда
				Try
					ЗагружаемыйОбъект[КлючИЗначение.Ключ] = КлючИЗначение.Значение;
				Исключение
					mErrorMessage("Ошибка при установки значения реквизита """ + КлючИЗначение.Ключ + ""
						+ ОписаниеОшибки());
					Отказ = True;
					Прервать;
				EndTry;
			EndIf;

		EndDo;

		Если Object.ImportMode = 0 Тогда
			Если Не Отказ И ЗаписатьОбъект(ЗагружаемыйОбъект, ТекстыЯчеек, Object.BeforeWriteObject,
				Object.OnWriteObject) Тогда
				Сообщить(?(ОбъектНайден, "Изменен", "Загружен") + ?(ЗагружаемыйОбъект.ЭтоГруппа, " группа", " элемент") 
							+ " справочника: " + ЗагружаемыйОбъект.Ссылка,
						СтатусСообщения.Информация);
				Загружено = Загружено + 1;
			Иначе
				Сообщить("Объект не " + ?(ОбъектНайден, "изменен", "загружен") + ". " 
						+ ?(ЗагружаемыйОбъект.ЭтоГруппа, " Группа", " Элемент") + " справочника: "
					+ ЗагружаемыйОбъект + ".", СтатусСообщения.Важное);
			EndIf;
		ElsIf Object.ImportMode = 1 Тогда

			Если Не ОбработатьСобытиеПослеДобавленияСтроки(ОбъектИсточника, ЗагружаемыйОбъект, ТекстыЯчеек,
				Object.AfterAddRow) Тогда
				Отказ = True;
			EndIf;

			Если Не Отказ Тогда
				Сообщить("Добавлена строка: " + (Загружено + 1));
			Иначе
				Сообщить("При добавлении строки " + (Загружено + 1) + " возникли ошибки. ");
				ЗаписыватьОбъект = False;
			EndIf;

			Загружено = Загружено + 1;

		ElsIf Object.ImportMode = 2 Тогда
			Если Не Отказ И ЗаписатьОбъект(ЗагружаемыйОбъект, ТекстыЯчеек, Object.BeforeWriteObject,
				Object.OnWriteObject) Тогда
				Сообщить(?(ОбъектНайден, "Изменена", "Добавлена") + " запись № " + НомерТекущейСтроки + ".");
				Загружено = Загружено + 1;
			Иначе
				Сообщить("Запись не " + ?(ОбъектНайден, "изменена", "загружена") + ". № записи: " + НомерТекущейСтроки
					+ ".", СтатусСообщения.Важное);
			EndIf;
		EndIf;

	EndDo;
	Сообщить("---------------------------------------------", СтатусСообщения.БезСтатуса);

	Если Object.ImportMode = 1 Тогда
		Если ЗаписыватьОбъект И ЗаписатьОбъект(ОбъектИсточника, "", Object.BeforeWriteObject,
			Object.OnWriteObject) Тогда

			Сообщить("Выполнена загрузка" + ТекстВопросаИсточника, СтатусСообщения.Информация);
			Сообщить("" + Загружено + " из " + КоличествоЭлементов + " элементов.", СтатусСообщения.Информация);
			Return True;
		Иначе
			Сообщить("Объект не записан: " + ЗагружаемыйОбъект + ".", СтатусСообщения.Важное);
			Return False;
		EndIf;
	ElsIf Object.ImportMode = 0 Тогда
		Сообщить("Выполнена загрузка" + ТекстВопросаИсточника, СтатусСообщения.Информация);
		Сообщить("" + Загружено + " из " + КоличествоЭлементов + " элементов.", СтатусСообщения.Информация);
		Return True;
	ElsIf Object.ImportMode = 2 Тогда
		Сообщить("Выполнена загрузка" + ТекстВопросаИсточника, СтатусСообщения.Информация);
		Сообщить("" + Загружено + " из " + КоличествоЭлементов + " записей.", СтатусСообщения.Информация);
		Return True;
	EndIf;

EndFunction

// Function определяет возможность создания группы для переданного метаданного
//
// Параметры:
//  МетаданныеИсточника - Метаданные - Метаданные загружаемого объекта
//
// Возвращаемое значение:
//  Булево - признак возможности создания группы
//
&AtServer
Function ВозможноСозданиеГруппы(Знач МетаданныеИсточника)
	
	Return МетаданныеИсточника.Иерархический 
			И МетаданныеИсточника.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов;

EndFunction // ()

// Function вычисляет значение ячейки для режима "Вычислять"
//
// Параметры:
//  Expression - програмный код, который необходимо выполнить
//  ТекущиеДанные  - структура загруженных значений
//  ТекстЯчейки    - текст текущей ячейки
//  ТекстыЯчеек    - массив текстов ячеек строки
//  Результат      - результат вычисления
//
// Возвращаемое значение:
//  Структура, сордержащая Результат и ОписаниеОшибки
&AtServerБезКонтекста
Function ВычислитьЗначениеЯчейки(Знач Выражение, Знач ТекущиеДанные, Знач ТекстЯчейки, Знач ТекстыЯчеек, Знач Результат)

	ТекстЯчейки = СокрЛП(ТекстЯчейки);
	ОписаниеОшибки = "";
	Try
		Выполнить (Выражение);
	Исключение
		mErrorMessage(ОписаниеОшибки());
	EndTry;

	Return Новый Структура("Результат,ОписаниеОшибки", Результат, ОписаниеОшибки);

EndFunction // ВычислитьЗначениеЯчейки(ТекущаяСтрока,Представление)()

// Function записывает объект в информационную базу данных, используя
// события определенные пользователем в форме редактирования событий
//
// Параметры:
//  Объект      - записываемый объект
//  ТекстыЯчеек - массив текстов ячеек, загружаемой строки
//
// Возвращаемое значение:
//  True, если объект записан, False - иначе
//
&AtServerБезКонтекста
Function ЗаписатьОбъект(Объект, ТекстыЯчеек = Undefined, ПередЗаписьюОбъекта, ПриЗаписиОбъекта)

	Отказ = False;
	НачатьТранзакцию();
	Если Не ПустаяСтрока(ПередЗаписьюОбъекта) Тогда
		Try
			Выполнить (ПередЗаписьюОбъекта);
			Если Отказ Тогда
				ОписаниеОшибки = "";//Установлен отказ перед записью объекта
			EndIf;
		Исключение
			Отказ = True;
			ОписаниеОшибки = ОписаниеОшибки();
		EndTry;
	EndIf;

	Если Не Отказ Тогда
		Try
			Объект.Записать();
		Исключение
			Отказ = True;
			ОписаниеОшибки = ОписаниеОшибки();
		EndTry;
	EndIf;

	Если Не Отказ И Не ПустаяСтрока(ПриЗаписиОбъекта) Тогда

		Try
			Выполнить (ПриЗаписиОбъекта);
			Если Отказ Тогда
				ОписаниеОшибки = "";//Установлен отказ при записи объекта
			EndIf;

		Исключение
			Отказ = True;
			ОписаниеОшибки = ОписаниеОшибки();
		EndTry;

		Если Не Отказ Тогда
			Try
				Объект.Записать();
			Исключение
				Отказ = True;
				ОписаниеОшибки = ОписаниеОшибки();
			EndTry;
		EndIf;

	EndIf;

	Если Не Отказ Тогда
		ЗафиксироватьТранзакцию();
	Иначе
		mErrorMessage(ОписаниеОшибки);
		ОтменитьТранзакцию();
	EndIf;

	Return Не Отказ;

EndFunction // ()

// Function обрабатывает событие "После добавления строки",
// определенное пользователем в форме редактирования событий
//
// Параметры:
//  Объект      - записываемый объект
//  ТекущиеДанные  - структура загруженных значений
//  ТекстыЯчеек    - массив текстов ячеек строки
//
// Возвращаемое значение:
//  True, если в событие "После добавления строки" не был установлен Отказ, False - иначе
//
&AtServerБезКонтекста
Function ОбработатьСобытиеПослеДобавленияСтроки(Объект, ТекущиеДанные, ТекстыЯчеек, ПослеДобавленияСтроки)

	Try

		Выполнить (ПослеДобавленияСтроки);

	Исключение

		mErrorMessage(ОписаниеОшибки());
		Return False;

	EndTry;

	Return True;

EndFunction // ()

////////////////////////////////////////////////////////////////////////////////
//

// Procedure выполняет контроль заполнения данных табличного документа
// сообщает об ошибках и устанавливает коментарии к ошибочным ячейкам
//
// Параметры:
//  SpreadsheetDocument - SpreadsheetDocument, у которого необходимо сформировать шапку
//  Индикатор         - Элемент управления индикатор, в котором необходимо отображать процент выполнения операции
//
&AtServer
Procedure КонтрольЗаполнения(ТабличныйДокумент) Экспорт

	КоличествоЭлементов = ТабличныйДокумент.ВысотаТаблицы - Object.SpreadsheetDocumentFirstDataRow + 1;

	КоличествоОшибок = 0;
	Для К = 0 По КоличествоЭлементов - 1 Цикл
		//Состояние("Выполняется контроль заполнения строки № " + (К + 1));
		КонтрольЗаполненияСтроки(ТабличныйДокумент, К + Object.SpreadsheetDocumentFirstDataRow, ,
			КоличествоОшибок);
	EndDo;

	Сообщить("Контроль заполнения завершен. Проверено строк: " + КоличествоЭлементов);
	Если КоличествоОшибок Тогда
		Сообщить("Выявлено ячеек, содержащих ошибки/неоднозначное представление: " + КоличествоОшибок);
	Иначе
		Сообщить("Ячеек, содержащих ошибки не выявлено");
	EndIf;

EndProcedure // FillControl()

// Function выполняет контроль заполнения строки данных табличного документа
// сообщает об ошибках и устанавливает коментарии к ошибочным ячейкам
//
// Параметры:
//  SpreadsheetDocument - SpreadsheetDocument, у которого необходимо сформировать шапку
//  НомерСтроки       - Число, номер строки табличного документа
//  ТекстыЯчеек    - возвращает массив текстов ячеек строки,
//
// Возвращаемое значение:
//  структура, ключ - Имя загружаемого реквизита, Значение - Значение загружаемого реквизита
//
&AtServer
Function КонтрольЗаполненияСтроки(ТабличныйДокумент, НомерСтроки, ТекстыЯчеек = Undefined, КоличествоОшибок = 0)

	ТекстыЯчеек = Новый Массив;
	ТекстыЯчеек.Добавить(Undefined);
	Для к = 1 По ТабличныйДокумент.ШиринаТаблицы Цикл
		ТекстыЯчеек.Добавить(СокрЛП(ТабличныйДокумент.Область("R" + Формат(НомерСтроки, "ЧГ=") + "C" + Формат(К,
			"ЧГ=")).Текст));
	EndDo;

	Колонки = Object.AdditionalProperties.Колонки;

	ТекущаяСтрока     = Новый Структура;
	Для Каждого КлючИЗначение Из Колонки Цикл

		Колонка = КлючИЗначение.Значение;

		Если Колонка.Check Тогда

			Если Колонка.ImportMode = "Устанавливать" Тогда

				Результат = Колонка.DefaultValue;
				ТекущаяСтрока.Вставить(Колонка.ИмяРеквизита, Результат);

			ElsIf Не Колонка.ColumnNumber = 0 Тогда

				Если Не ОбработатьОбласть(ТабличныйДокумент.Область("R" + Формат(НомерСтроки, "ЧГ=") + "C" + Формат(
					Колонка.НомерКолонки, "ЧГ=")), Колонка, ТекущаяСтрока, ТекстыЯчеек) Тогда
					КоличествоОшибок = КоличествоОшибок + 1;
				EndIf;

			ElsIf Колонка.ImportMode = "Вычислять" Тогда

				Вычисление  = ВычислитьЗначениеЯчейки(Колонка.Выражение, ТекущаяСтрока, "", ТекстыЯчеек,
					Колонка.ЗначениеПоУмолчанию);
				Результат   = Вычисление.Результат;
				Примечание  = Вычисление.ОписаниеОшибки;

				Если Не ValueIsFilled(Результат) Тогда
					Результат = Колонка.DefaultValue;
				EndIf;

				ТекущаяСтрока.Вставить(Колонка.ИмяРеквизита, Результат);

				Если Не ПустаяСтрока(Примечание) Тогда
					Сообщить("Строка [" + НомерСтроки + "](" + Колонка.AttributePresentation + "): " + Примечание);
					КоличествоОшибок = КоличествоОшибок + 1;
				EndIf;

			EndIf;

		EndIf;

	EndDo;
	Return ТекущаяСтрока;

EndFunction

// Procedure выполняет обработку области табличного документа:
// заполняет расшифровку по представлению ячейки в соответствии со структурой загружаемых реквизитов
// сообщает об ошибке и устанавливает коментарий, если ячейка содержит ошибку
//
// Параметры:
//  Область - область табличного документа
//  Колонка - Структура, свойства, в соответствии с которыми необходимо выполнить обработку области
//  ТекущиеДанные  - структура загруженных значений
//  ТекстыЯчеек    - массив текстов ячеек строки
//
&AtServer
Function ОбработатьОбласть(Область, Колонка, ТекущиеДанные, ТекстыЯчеек)

	Представление = Область.Текст;
	Примечание = "";

	Если Колонка.ImportMode = "Вычислять" Тогда

		Вычисление = ВычислитьЗначениеЯчейки(Колонка.Выражение, ТекущиеДанные, Представление, ТекстыЯчеек,
			Колонка.ЗначениеПоУмолчанию);
		Если Не ПустаяСтрока(Вычисление.ОписаниеОшибки) Тогда
			Результат   = Undefined;
			Примечание = "" + Вычисление.ОписаниеОшибки;
		Иначе
			Результат = Вычисление.Результат;
		EndIf;

	ElsIf ПустаяСтрока(Представление) Тогда
		Результат = Undefined;
	Иначе
		НайденныеЗначения = ПолучитьВозможныеЗначения(Колонка, Представление, Примечание, ТекущиеДанные);

		Если НайденныеЗначения.Количество() = 0 Тогда

			Примечание = "Не найден" + ?(Примечание = "", "", Символы.ПС + Примечание);
			Результат = Undefined;

		ElsIf НайденныеЗначения.Количество() = 1 Тогда

			Результат = НайденныеЗначения[0];
		Иначе

			Примечание = "Не однозначное представление. Вариантов: " + НайденныеЗначения.Количество() + ?(Примечание
				= "", "", Символы.ПС + Примечание);

			Нашли = False;
			НашлиЗначениеПоУмолчанию = False;
			Для Каждого НайденноеЗначение Из НайденныеЗначения Цикл
				Если НайденноеЗначение = Область.Расшифровка Тогда
					Нашли = True;
					Прервать;
				EndIf;
				Если НайденноеЗначение = Колонка.DefaultValue Тогда
					НашлиЗначениеПоУмолчанию = True;
				EndIf;
			EndDo;

			Если Не Нашли Тогда

				Если НашлиЗначениеПоУмолчанию Тогда
					НайденноеЗначение = Колонка.DefaultValue;
				Иначе
					НайденноеЗначение = НайденныеЗначения[0];
				EndIf;
			EndIf;
			Результат = НайденноеЗначение;
		EndIf;
	EndIf;

	Если Не ValueIsFilled(Результат) Тогда
		Результат = Колонка.DefaultValue;
	EndIf;

	ТекущиеДанные.Вставить(Колонка.ИмяРеквизита, Результат);

	Область.Расшифровка = Результат;
	Область.Примечание.Текст = Примечание;

	Если Не ПустаяСтрока(Примечание) Тогда
		Сообщить("Ячейка[" + Область.Имя + "](" + Колонка.AttributePresentation + "): " + Примечание);
	EndIf;

	Return ПустаяСтрока(Примечание);

EndFunction

// Function возвращает массив возможных значений для текущей колонки по представлению
//
// Параметры:
//  Колонка - Структура, свойства, в соответствии с которыми необходимо получить возможные значения
//  Представление - Строка, по которой необходимо вернуть массив значений
//  Примечание    - массив текстов ячеек строки
//  ТекущиеДанные  - структура загруженных значений
//
// Возвращаемое значение:
//  массив возможных значений
//
&AtServer
Function ПолучитьВозможныеЗначения(Колонка, Представление, Примечание, ТекущиеДанные)
	Примечание = "";

	НайденныеЗначения = Новый Массив;

	Если ПустаяСтрока(Представление) Тогда

		Return НайденныеЗначения;

	Иначе
		СвязьПоТипу = Undefined;
		Если Не ПустаяСтрока(Колонка.СвязьПоТипу) Тогда

			Если ТипЗНЧ(Колонка.СвязьПоТипу) = Тип("Строка") Тогда
				ТекущиеДанные.Свойство(Колонка.СвязьПоТипу, СвязьПоТипу);
			Иначе
				СвязьПоТипу = Колонка.LinkByType;
			EndIf;
			Если Не СвязьПоТипу = Undefined Тогда

				ЭлементСвязиПоТипу = Колонка.LinkByTypeItem;
				Если ЭлементСвязиПоТипу = 0 Тогда
					ЭлементСвязиПоТипу = 1;
				EndIf;
				ВидыСубконто = СвязьПоТипу.ВидыСубконто;
				Если ЭлементСвязиПоТипу > ВидыСубконто.Количество() Тогда
					Return НайденныеЗначения;
				EndIf;
				Тип = СвязьПоТипу.ВидыСубконто[ЭлементСвязиПоТипу - 1].ВидСубконто.ТипЗначения;
			Иначе
				Тип = Колонка.TypeDescription;
			EndIf;

		Иначе
			Тип = Колонка.TypeDescription;
		EndIf;
	EndIf;
	ПримитивныеТипы = Новый Структура("Число, Строка, Дата, Булево", Тип("Число"), Тип("Строка"), Тип("Дата"), Тип(
		"Булево"));
	Для Каждого ТипРеквизита Из Тип.Типы() Цикл

		Если ТипРеквизита = ПримитивныеТипы.Число Или ТипРеквизита = ПримитивныеТипы.Булево Тогда
			НайденныеЗначения.Добавить(mAdjustToNumber(Представление, Колонка.ОписаниеТипов, Примечание));
		ElsIf ТипРеквизита = ПримитивныеТипы.Строка Или ТипРеквизита = ПримитивныеТипы.Дата Тогда
			НайденныеЗначения.Добавить(мПривестиКДате(Представление, Колонка.ОписаниеТипов, Примечание));

		Иначе

			МетаданныеТипа = Метаданные.НайтиПоТипу(ТипРеквизита);

			Если Перечисления.ТипВсеСсылки().СодержитТип(ТипРеквизита) Тогда
				
				//Это Перечисление
				Для Каждого Перечисление Из ПолучитьМенеджераПоТипу(ТипРеквизита) Цикл
					Если Строка(Перечисление) = Представление Тогда
						НайденныеЗначения.Добавить(Перечисление);
					EndIf;
				EndDo;

			ElsIf Документы.ТипВсеСсылки().СодержитТип(ТипРеквизита) Тогда
				
				//Это документ

				Менеджер = ПолучитьМенеджераПоТипу(ТипРеквизита);
				Если Колонка.SearchBy = "Номер" Тогда
					//НайденноеЗначение = Менеджер.НайтиПоКоду(Представление);
				ElsIf Колонка.SearchBy = "Дата" Тогда
					//НайденноеЗначение = Менеджер.Найти
				Иначе

					ДлиннаСинонима = СтрДлина("" + МетаданныеТипа);

					Если Лев(Представление, ДлиннаСинонима) = "" + МетаданныеТипа Тогда
						НомерИДата = СокрЛП(Сред(Представление, ДлиннаСинонима + 1));
						ПозицияОт = Найти(НомерИДата, " от ");
						Если Не ПозицияОт = 0 Тогда
							НомерДок = Лев(НомерИДата, ПозицияОт - 1);
							Try
								ДатаДок  = Дата(Сред(НомерИДата, ПозицияОт + 4));
							Исключение
								ДатаДок = Undefined;
							EndTry;
							Если Не ДатаДок = Undefined Тогда
								НайденноеЗначение = Менеджер.НайтиПоНомеру(НомерДок, ДатаДок);
								Если Не НайденноеЗначение.Пустая() Тогда
									НайденныеЗначения.Добавить(НайденноеЗначение);
								EndIf;
							EndIf;
						EndIf;
					EndIf;

				EndIf;

			ElsIf Не МетаданныеТипа = Undefined Тогда

				ИскатьПо = Колонка.SearchBy;
				ЭтоСправочник = Справочники.ТипВсеСсылки().СодержитТип(ТипРеквизита);
				Если ПустаяСтрока(ИскатьПо) Тогда
					СтрокаОсновногоПредставления = Строка(МетаданныеТипа.ОсновноеПредставление);

					Если СтрокаОсновногоПредставления = "ВВидеКода" Тогда
						ИскатьПо = "Код";
					ElsIf СтрокаОсновногоПредставления = "ВВидеНаименования" Тогда
						ИскатьПо = "Наименование";
					ElsIf СтрокаОсновногоПредставления = "ВВидеНомера" Тогда
						ИскатьПо = "Номер";
					EndIf;
				EndIf;
				Запрос = Новый Запрос;
				Запрос.Текст = "ВЫБРАТЬ
							   |	_Таблица.Ссылка
							   |ИЗ
							   |	" + МетаданныеТипа.ПолноеИмя() + " КАК _Таблица
																	 |ГДЕ";

				Запрос.Текст = Запрос.Текст + "
											  |	_Таблица." + ИскатьПо + " = &Представление";
				Запрос.УстановитьПараметр("Представление", Представление);

				Если ЭтоСправочник И Не ПустаяСтрока(Колонка.СвязьПоВладельцу) И МетаданныеТипа.Владельцы.Количество() Тогда

					СвязьПоВладельцу = Undefined;
					Если ТипЗНЧ(Колонка.СвязьПоВладельцу) = Тип("Строка") Тогда
						ТекущиеДанные.Свойство(Колонка.СвязьПоВладельцу, СвязьПоВладельцу);
					Иначе
						СвязьПоВладельцу = Колонка.LinkByOwner;
					EndIf;

					Если Не СвязьПоВладельцу = Undefined Тогда
						Запрос.Текст = Запрос.Текст + "
													  |	И _Таблица.Владелец = &LinkByOwner";
						Запрос.УстановитьПараметр("LinkByOwner", СвязьПоВладельцу);
					EndIf;

				EndIf;

				Выборка =  Запрос.Выполнить().Выбрать();

				Пока Выборка.Следующий() Цикл
					НайденныеЗначения.Добавить(Выборка.Ссылка);
				EndDo;
			Иначе
				Примечание = "Не описан способ поиска";
				Примечание = "Для Колонки не определен тип значения";
			EndIf;
		EndIf;

	EndDo;
	Return НайденныеЗначения;
EndFunction // ()

////////////////////////////////////////////////////////////////////////////////
//

// Function возвращает массив, элементами которого выступают возможные имена представления загружаемого реквизита
//
// Параметры:
//  ЗагружаемыйРеквизит - Строка таблицы значений загружаемого реквизита
//
// Возвращаемое значение:
//  список значений; значение списка - строка имя представления
//
&AtServer
Function ПолучитьСписокИменПредставлений(ОписаниеТипов)

	СписокВыбора = Новый СписокЗначений;
	Если ОписаниеТипов.Типы().Количество() = 1 Тогда

		Тип = ОписаниеТипов.Типы()[0];

		МетаданныеТипа      = Метаданные.НайтиПоТипу(Тип);
		ЭтоСправочник       = Справочники.ТипВсеСсылки().СодержитТип(Тип);
		ЭтоСчет             = ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип);
		ЭтоВидХарактеристик = ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип);
		Если ЭтоСправочник Или ЭтоСчет Или ЭтоВидХарактеристик Тогда

			ЕстьКод = МетаданныеТипа.ДлинаКода > 0;
			ЕстьИмя = МетаданныеТипа.ДлинаНаименования > 0;

			ВидОсновногоПредставление = ?(ЭтоСправочник, Метаданные.СвойстваОбъектов.ОсновноеПредставлениеСправочника,
				?(ЭтоСчет, Метаданные.СвойстваОбъектов.ОсновноеПредставлениеСчета,
				Метаданные.СвойстваОбъектов.ОсновноеПредставлениеВидаХарактеристики));

			Если МетаданныеТипа.ОсновноеПредставление = ВидОсновногоПредставление.ВВидеКода Тогда

				Если ЕстьКод Тогда
					СписокВыбора.Добавить("Код", "Код");
				EndIf;

				Если ЕстьИмя Тогда
					СписокВыбора.Добавить("Наименование", "Наименование");
				EndIf;

			Иначе

				Если ЕстьИмя Тогда
					СписокВыбора.Добавить("Наименование", "Наименование");
				EndIf;

				Если ЕстьКод Тогда
					СписокВыбора.Добавить("Код", "Код");
				EndIf;

			EndIf;

			Для Каждого Реквизит Из МетаданныеТипа.Реквизиты Цикл

				Если Не Реквизит.Индексирование = Метаданные.СвойстваОбъектов.Индексирование.НеИндексировать
					И Реквизит.Тип.Типы().Количество() = 1 И Реквизит.Тип.Типы()[0] = Тип("Строка") Тогда

					СписокВыбора.Добавить(Реквизит.Имя, Реквизит.Представление());

				EndIf;

			EndDo;
		Иначе
		
		EndIf;

	EndIf;
	Return СписокВыбора;
EndFunction // ()

// Function возвращает список, элементами которого выступают возможные связи по типу для загружаемого реквизита
//
// Параметры:
//  ЗагружаемыйРеквизит - Строка таблицы значений загружаемого реквизита
//
// Возвращаемое значение:
//  список значений; значение списка - строка имя колонки связи или ссылка на элемент связи
//
&AtServer
Function ПолучитьСписокСвязейПоТипу(ЗагружаемыйРеквизит, ТЗ)

	СписокВыбора = Новый СписокЗначений;

	ВозможныеПланыСчетов = Новый Структура;
	Для Каждого ПланСчетов Из Метаданные.ПланыСчетов Цикл
		Try
			Если ПланСчетов.ВидыСубконто.Тип = ЗагружаемыйРеквизит.TypeDescription Тогда

				ВозможныеПланыСчетов.Вставить(ПланСчетов.Имя, ПланыСчетов[ПланСчетов.Имя]);

			EndIf;
		Исключение

		EndTry;
	EndDo;

	Для Каждого ПланСчетов Из ВозможныеПланыСчетов Цикл
		ТипЗНЧПланСчетов = ТипЗНЧ(ПланСчетов.Значение.ПустаяСсылка());
		Для Каждого КолонкаСвязиПоТипу Из ТЗ Цикл
			Если КолонкаСвязиПоТипу.TypeDescription.Типы()[0] = ТипЗНЧПланСчетов Тогда
				СписокВыбора.Добавить(КолонкаСвязиПоТипу.ИмяРеквизита, КолонкаСвязиПоТипу.ИмяРеквизита);
			EndIf;
		EndDo;
	EndDo;

	Если Не ВозможныеПланыСчетов.Количество() = 0 Тогда
		СписокВыбора.Добавить(Undefined, "< пустое значение >");
	EndIf;

	Для Каждого ПланСчетов Из ВозможныеПланыСчетов Цикл
		СписокВыбора.Добавить("ПланСчетовСсылка." + ПланСчетов.Ключ, "<" + ПланСчетов.Ключ + ">");
	EndDo;

	Return СписокВыбора;
EndFunction // ()

// Function возвращает список, элементами которого выступают возможные связи по владельцу для загружаемого реквизита
//
// Параметры:
//  ЗагружаемыйРеквизит - Строка таблицы значений загружаемого реквизита
//
// Возвращаемое значение:
//  список значений; значение списка - строка имя колонки связи или ссылка на элемент связи
//
&AtServer
Function ПолучитьСписокСвязейПоВладельцу(ОписаниеТипов, ТаблицаКолонок)

	ЕстьТипСамогоОбъекта = False;
	МетаданныеИсточника = ПолучитьМетаданныеИсточника();
	Если Object.ImportMode = 0 Тогда
		ОписаниеТиповСправочника = Тип(СтрЗаменить(МетаданныеИсточника.ПолноеИмя(), ".", "Ссылка."));
	Иначе
		ОписаниеТиповСправочника = Undefined;
	EndIf;

	СписокВыбора = Новый СписокЗначений;
	ТипыВладельцев = Новый Соответствие;
	Для Каждого ТипКолонки Из ОписаниеТипов.Типы() Цикл
		Если Справочники.ТипВсеСсылки().СодержитТип(ТипКолонки) Тогда
			Для Каждого Владелец Из Метаданные.НайтиПоТипу(ТипКолонки).Владельцы Цикл
				ТипВладельца   = Тип(СтрЗаменить(Владелец.ПолноеИмя(), ".", "Ссылка."));
				Если ТипыВладельцев[ТипВладельца] = Undefined Тогда

					Если ТипВладельца = ОписаниеТиповСправочника Тогда

						ЕстьТипСамогоОбъекта = True;

					EndIf;

					ТипыВладельцев.Вставить(Владелец.ПолноеИмя(), Владелец.ПолноеИмя());
					Для Каждого КолонкаСвязиПоВладельцу Из ТаблицаКолонок Цикл
						Если КолонкаСвязиПоВладельцу.TypeDescription.Типы()[0] = ТипВладельца
							И СписокВыбора.НайтиПоЗначению(КолонкаСвязиПоВладельцу.ИмяРеквизита) = Undefined Тогда
							// Возможно надо будет по всем типам проходить
							СписокВыбора.Добавить(КолонкаСвязиПоВладельцу.ИмяРеквизита,
								КолонкаСвязиПоВладельцу.ИмяРеквизита);
						EndIf;
					EndDo;
				EndIf;
			EndDo;
		EndIf;
	EndDo;

	Если Не ТипыВладельцев.Количество() = 0 Тогда
		СписокВыбора.Добавить(Undefined, "< пустое значение >");
	EndIf;
	Для Каждого КлючИЗначение Из ТипыВладельцев Цикл
		СписокВыбора.Добавить(КлючИЗначение.Значение, "<" + КлючИЗначение.Значение + ">");
	EndDo;

	Если ЕстьТипСамогоОбъекта Тогда

		СписокВыбора.Вставить(0, "<Создаваемый объект>", "<Создаваемый объект>");

	EndIf;

	Return СписокВыбора;

EndFunction // ()

// Возвращает список выбора, закэшированный в таблице значений для реквизита
//
// Параметры
//  AttributeName  - Строка - Имя реквизита, для которого нужно
//		получить связанный список выбора
//
// Возвращаемое значение:
//   СписокЗначений - список значений для выбора для этого реквизита
//
&AtServer
Function ПолучитьСписокВыбораСвязиПоВладельцу(ИмяРеквизита)

	ТЗ = FormAttributeToValue("СпискиВыбораСвязиПоВладельцу");
	Стр = ТЗ.Найти(ИмяРеквизита, "AttributeName");

	Return Стр.СписокВыбора;

EndFunction // ПолучитьСписокВыбораСвязиПоВладельцу()

// Сохраняет в кэше список выбора для реквизита
//
// Параметры
//  AttributeName  - Строка - Имя реквизита, для которого нужно
//		сохранить связанный список выбора
//  НовыйСписокВыбора  - СписокЗначений - сохраняемый список значений
//
&AtServer
Procedure СохранитьСписокВыбораСвязиПоВладельцу(ИмяРеквизита, Знач НовыйСписокВыбора)

	ТЗ = FormAttributeToValue("СпискиВыбораСвязиПоВладельцу");
	Стр = ТЗ.Найти(ИмяРеквизита, "AttributeName");
	Стр.СписокВыбора = НовыйСписокВыбора;
	ЗначениеВРеквизитФормы(ТЗ, "СпискиВыбораСвязиПоВладельцу");

EndProcedure // СохранитьСписокВыбораСвязиПоВладельцу()

&AtServer
Procedure КонтрольЗаполненияСервер()

	СформироватьСтруктуруКолонок();
	КоличествоЭлементов = SpreadsheetDocument.ВысотаТаблицы - Object.SpreadsheetDocumentFirstDataRow + 1;

	КоличествоОшибок = 0;
	Для К = 0 По КоличествоЭлементов - 1 Цикл
		//Состояние("Выполняется контроль заполнения строки № " + (К + 1));
		КонтрольЗаполненияСтроки(SpreadsheetDocument, К + Object.SpreadsheetDocumentFirstDataRow, ,
			КоличествоОшибок);
	EndDo;

	Сообщить("Контроль заполнения завершен. Проверено строк: " + КоличествоЭлементов);
	Если КоличествоОшибок Тогда
		Сообщить("Выявлено ячеек, содержащих ошибки/неоднозначное представление: " + КоличествоОшибок);
	Иначе
		Сообщить("Ячеек, содержащих ошибки не выявлено");
	EndIf;

EndProcedure // КонтрольЗаполненияСервер()

////////////////////////////////////////////////////////////////////////////////
//

// Заполняет настройки колонок по умолчанию или по переданным настройкам
//
// Параметры:
//  Настройки - табличный документ или Undefined
//
&AtServer
Procedure ЗаполнитьНастройкиКолонок(Настройки)

	ПередЗаписьюОбъекта   = "";
	ПриЗаписиОбъекта      = "";
	ПослеДобавленияСтроки = "";

	Если ТипЗнч(Настройки) = Тип("SpreadsheetDocument") Тогда

		ВерсияОбработки = СокрЛП(Настройки.Область("R1C5").Текст);
		Если ВерсияОбработки = "1.2" Тогда
			ТекущаяСтрока = 11; //Строка с которой начинается таблица реквизитов
		ElsIf ВерсияОбработки = "1.3" Тогда
			ТекущаяСтрока = 11; //Строка с которой начинается таблица реквизитов			
		Иначе
			ВерсияОбработки = "1.1";
			ТекущаяСтрока = 9; //Строка с которой начинается таблица реквизитов
		EndIf;
		Try

			ТекстВосстановленногоРежимаЗагрузки = СокрЛП(Настройки.Область(?(ВерсияОбработки = "1.1", "R1", "R2")
				+ "C5").Текст);
			Если ТекстВосстановленногоРежимаЗагрузки = "в справочник" Или ТекстВосстановленногоРежимаЗагрузки = "" Тогда
				ВосстановленныйРежимЗагрузки = 0;
			ElsIf ТекстВосстановленногоРежимаЗагрузки = "в табличную часть" Или ТекстВосстановленногоРежимаЗагрузки
				= "Х" Тогда
				ВосстановленныйРежимЗагрузки = 1;
			ElsIf ТекстВосстановленногоРежимаЗагрузки = "в регистр сведений" Тогда
				ВосстановленныйРежимЗагрузки = 2;
			EndIf;

			МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(Настройки.Область(?(ВерсияОбработки = "1.1", "R2", "R3")
				+ "C5").Текст);
			Если МетаданныеОбъекта = Undefined Тогда
				ВызватьИсключение "Неправильный формат файла";
			EndIf;

			Если ВосстановленныйРежимЗагрузки = 0 Тогда
				ВосстановленныйСсылкаИсточника = Новый (СтрЗаменить(МетаданныеОбъекта.ПолноеИмя(), ".", "Ссылка."));
			ElsIf ВосстановленныйРежимЗагрузки = 1 Тогда
				ВосстановленныйСсылкаИсточника = Новый (СтрЗаменить(МетаданныеОбъекта.Родитель().ПолноеИмя(), ".",
					"Ссылка."));
			Иначе
				ВосстановленныйСсылкаИсточника = Undefined;
			EndIf;
			
			//SourceRef = ПустаяСсылка();
			СтруктураУмолчаний = Новый Структура;
			ТекущаяСтрокаОбласти = "R" + Формат(ТекущаяСтрока, "ЧГ=");
			ИмяРеквизита = Настройки.Область(ТекущаяСтрокаОбласти + "C2").Текст;
			Пока Не ПустаяСтрока(ИмяРеквизита) Цикл
				СтруктураУмолчанияРеквизита = Новый Структура;
				СтруктураУмолчанияРеквизита.Вставить("AttributeName", ИмяРеквизита);
				СтруктураУмолчанияРеквизита.Вставить("Check", Не ПустаяСтрока(Настройки.Область(ТекущаяСтрокаОбласти
					+ "C1").Текст));
				СтруктураУмолчанияРеквизита.Вставить("SearchField", Не ПустаяСтрока(Настройки.Область(
					ТекущаяСтрокаОбласти + "C3").Текст));

				Типы = Новый Массив;
				ОписаниеТиповСтрокой = Настройки.Область(ТекущаяСтрокаОбласти + "C4").Текст;
				Для к = 1 По СтрЧислоСтрок(ОписаниеТиповСтрокой) Цикл

					кс = Undefined;
					кч = Undefined;
					кд = Undefined;
					МассивЧастейТипа = mSplitStringIntoSubstringsArray(НРег(СокрЛП(СтрПолучитьСтроку(
						ОписаниеТиповСтрокой, к))), ",");
					Если МассивЧастейТипа.Количество() = 0 Тогда
						Продолжить;
					ElsIf Найти(МассивЧастейТипа[0], ".") Тогда
						Тип = Тип(СтрЗаменить(МассивЧастейТипа[0], ".", "Ссылка."));
					ElsIf МассивЧастейТипа[0] = "строка" Тогда
						Тип = Тип("Строка");
						Если МассивЧастейТипа.Количество() = 2 Тогда
							кс = Новый КвалификаторыСтроки(mAdjustToNumber(МассивЧастейТипа[1]),
								ДопустимаяДлина.Переменная);
						ElsIf МассивЧастейТипа.Количество() = 3 Тогда
							кс = Новый КвалификаторыСтроки(mAdjustToNumber(МассивЧастейТипа[1]),
								ДопустимаяДлина.Фиксированная);
						Иначе
							кс = Новый КвалификаторыСтроки;
						EndIf;
					ElsIf МассивЧастейТипа[0] = "число" Тогда
						Тип = Тип("Число");
						кч = Новый КвалификаторыЧисла(mAdjustToNumber(МассивЧастейТипа[1]), mAdjustToNumber(
							МассивЧастейТипа[2]), ?(МассивЧастейТипа.Количество() = 4, ДопустимыйЗнак.Неотрицательный,
							ДопустимыйЗнак.Любой));
					ElsIf МассивЧастейТипа[0] = "булево" Тогда
						Тип = Тип("Булево");
					ElsIf МассивЧастейТипа[0] = "дата" Тогда
						Тип = Тип("Дата");
						кд = Новый КвалификаторыДаты(ЧастиДаты.Дата);
					ElsIf МассивЧастейТипа[0] = "время" Тогда
						Тип = Тип("Дата");
						кд = Новый КвалификаторыДаты(ЧастиДаты.Время);
					ElsIf МассивЧастейТипа[0] = "дата и время" Тогда
						Тип = Тип("Дата");
						кд = Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя);
					Иначе
						Продолжить;
					EndIf;
					Типы.Добавить(Тип);
				EndDo;
				ОписаниеТипов = Новый ОписаниеТипов(Типы, кч, кс, кд);
				СтруктураУмолчанияРеквизита.Вставить("TypeDescription", ОписаниеТипов);

				РежимЗагрузкиРеквизита = Настройки.Область(ТекущаяСтрокаОбласти + "C5").Текст;

				СтруктураУмолчанияРеквизита.Вставить("ImportMode", РежимЗагрузкиРеквизита);

				ЗначениеПоУмолчанию = Настройки.Область(ТекущаяСтрокаОбласти + "C6").Текст;
				СтруктураУмолчанияРеквизита.Вставить("DefaultValue", ?(ПустаяСтрока(ЗначениеПоУмолчанию),
					ОписаниеТипов.ПривестиЗначение(Undefined), ЗначениеИзСтрокиВнутр(ЗначениеПоУмолчанию)));

				Если РежимЗагрузкиРеквизита = "Вычислять" Тогда
					СтруктураУмолчанияРеквизита.Вставить("Expression", Настройки.Область(ТекущаяСтрокаОбласти
						+ "C7").Текст);
				Иначе
					СтруктураУмолчанияРеквизита.Вставить("SearchBy", Настройки.Область(ТекущаяСтрокаОбласти
						+ "C7").Текст);

					СвязьПоВладельцу   = Настройки.Область(ТекущаяСтрокаОбласти + "C8").Текст;
					СтруктураУмолчанияРеквизита.Вставить("LinkByOwner", ?(Лев(СвязьПоВладельцу, 1) = "{",
						ЗначениеИзСтрокиВнутр(СвязьПоВладельцу), СвязьПоВладельцу));

					СвязьПоТипу        = Настройки.Область(ТекущаяСтрокаОбласти + "C9").Текст;
					СтруктураУмолчанияРеквизита.Вставить("LinkByType", ?(Лев(СвязьПоТипу, 1) = "{",
						ЗначениеИзСтрокиВнутр(СвязьПоТипу), СвязьПоТипу));

					СтруктураУмолчанияРеквизита.Вставить("LinkByTypeItem", mAdjustToNumber(Настройки.Область(
						ТекущаяСтрокаОбласти + "C10").Текст));
				EndIf;
				Если ВерсияОбработки = "1.3" Тогда
					СтруктураУмолчанияРеквизита.Вставить("ColumnNumber", mAdjustToNumber(Настройки.Область(
						ТекущаяСтрокаОбласти + "C11").Текст));
				EndIf;

				СтруктураУмолчаний.Вставить(ИмяРеквизита, СтруктураУмолчанияРеквизита);
				ТекущаяСтрока = ТекущаяСтрока + 1;
				ТекущаяСтрокаОбласти = "R" + Формат(ТекущаяСтрока, "ЧГ=");
				ИмяРеквизита = Настройки.Область(ТекущаяСтрокаОбласти + "C2").Текст;

			EndDo;

		Исключение
			mErrorMessage(ОписаниеОшибки());
		EndTry;
		
		//МетаданныеИсточника = ПолучитьМетаданныеИсточника();
		//Если МетаданныеИсточника = Undefined Тогда
		//	Return;
		//EndIf;

		Object.ImportMode   = ВосстановленныйРежимЗагрузки;
		Если ВосстановленныйРежимЗагрузки = 0 Тогда
			Object.CatalogObjectType = МетаданныеОбъекта.Имя;
		ElsIf ВосстановленныйРежимЗагрузки = 1 Тогда
			//Объект.SourceRef = ВосстановленныйСсылкаИсточника;
			Object.SourceTabularSection = ?(ВосстановленныйРежимЗагрузки, МетаданныеОбъекта.Имя, Undefined);
		ElsIf ВосстановленныйРежимЗагрузки = 2 Тогда
			Object.RegisterTypeName = МетаданныеОбъекта.Имя;
		EndIf;
		Object.DontCreateNewItems                 = Не ПустаяСтрока(Настройки.Область(?(ВерсияОбработки = "1.1",
			"R3", "R4") + "C5").Текст);
		Object.ReplaceExistingRecords = ?(ВерсияОбработки = "1.1", False, Не ПустаяСтрока(Настройки.Область(
			"R5C5").Текст));
		Object.ManualSpreadsheetDocumentColumnsNumeration = Не ПустаяСтрока(Настройки.Область(?(ВерсияОбработки = "1.1",
			"R4", "R6") + "C5").Текст);
		Object.SpreadsheetDocumentFirstDataRow     = mAdjustToNumber(Настройки.Область(?(ВерсияОбработки = "1.1",
			"R5", "R7") + "C5").Текст);

		Object.BeforeWriteObject = Настройки.Область("R" + Формат(ТекущаяСтрока + 2, "ЧГ=") + "C3").Текст;
		Object.OnWriteObject    = Настройки.Область("R" + Формат(ТекущаяСтрока + 3, "ЧГ=") + "C3").Текст;

		Если Object.ImportMode Тогда
			Object.AfterAddRow = Настройки.Область("R" + Формат(ТекущаяСтрока + 4, "ЧГ=") + "C3").Текст;
		EndIf;

		ТекущаяСтрока = ТекущаяСтрока + 1;

	EndIf;
	Оформление = Undefined;
	//МетаданныеИсточника = ПолучитьМетаданныеИсточника();

	ТЗ = FormAttributeToValue("ImportedAttributesTable");

	ТЗ.Очистить();

	Если Object.ImportMode = 0 Тогда
		ЗаполнитьНастройкиКолонокСправочника(ТЗ);
	ElsIf Object.ImportMode = 1 Тогда
		ЗаполнитьНастройкиКолонокТабличнойЧасти(ТЗ);
	ElsIf Object.ImportMode = 2 Тогда
		ЗаполнитьНастройкиКолонокРегистраСведений(ТЗ);
	EndIf;

	Если Не СтруктураУмолчаний = Undefined Тогда

		НомерКолонкиОформления = 0;
		НомерКолонки = 1;
		Для Каждого КлючИЗначение Из СтруктураУмолчаний Цикл
			Колонка = КлючИЗначение.Значение;
			ЗагружаемыйРеквизит = ТЗ.Найти(Колонка.ИмяРеквизита, "AttributeName");
			Если Не ЗагружаемыйРеквизит = Undefined Тогда
				Индекс = ТЗ.Индекс(ЗагружаемыйРеквизит);
				Если Индекс >= НомерКолонкиОформления Тогда
					ЗаполнитьЗначенияСвойств(ЗагружаемыйРеквизит, Колонка);

					ТЗ.Сдвинуть(ЗагружаемыйРеквизит, НомерКолонкиОформления - Индекс);
					Если Колонка.Check И Не ВерсияОбработки = "1.3" Тогда
						ЗагружаемыйРеквизит.ColumnNumber = НомерКолонки;
						НомерКолонки = НомерКолонки + 1;
					EndIf;
					НомерКолонкиОформления = НомерКолонкиОформления + 1;

				EndIf;
			EndIf;

		EndDo;

	Иначе
		НомерКолонки = 1;
		Для Каждого ЗагружаемыйРеквизит Из ТЗ Цикл

			ЗагружаемыйРеквизит.Check      = True;
			ЗагружаемыйРеквизит.ColumnNumber = НомерКолонки;
			НомерКолонки = НомерКолонки + 1;

		EndDo;

	EndIf;

	Для Каждого ЗагружаемыйРеквизит Из ТЗ Цикл
		Если ЗагружаемыйРеквизит.ImportMode = "Вычислять" Тогда
			ЗагружаемыйРеквизит.AdditionalConditionsPresentation = ЗагружаемыйРеквизит.Expression;
		Иначе
			ЗагружаемыйРеквизит.AdditionalConditionsPresentation = ?(ПустаяСтрока(ЗагружаемыйРеквизит.ИскатьПо), "", "Искать по "
				+ ЗагружаемыйРеквизит.SearchBy) + ?(ПустаяСтрока(ЗагружаемыйРеквизит.СвязьПоВладельцу), "",
				" по владельцу " + ЗагружаемыйРеквизит.LinkByOwner);
		EndIf;
	EndDo;

	ЗначениеВРеквизитФормы(ТЗ, "ImportedAttributesTable");

EndProcedure // ()

// Заполняет настройки колонок по умолчанию для табличной части
//
&AtServer
Procedure ЗаполнитьНастройкиКолонокТабличнойЧасти(ТЗ)

	МетаданныеИсточника = ПолучитьМетаданныеИсточника();

	Если МетаданныеИсточника = Undefined Тогда
		Return;
	EndIf;

	Для Каждого Реквизит Из МетаданныеИсточника.Реквизиты Цикл
		ЗагружаемыйРеквизит                        = ТЗ.Добавить();
		ЗагружаемыйРеквизит.AttributeName           = Реквизит.Имя;
		ЗагружаемыйРеквизит.AttributePresentation = Реквизит.Представление();
		ЗагружаемыйРеквизит.TypeDescription = МетаданныеИсточника.Реквизиты[ЗагружаемыйРеквизит.AttributeName].Тип;
	EndDo;

	Для Каждого ЗагружаемыйРеквизит Из ТЗ Цикл

		СписокВыбора = ПолучитьСписокИменПредставлений(ЗагружаемыйРеквизит.ОписаниеТипов);
		ЗагружаемыйРеквизит.SearchBy = ?(СписокВыбора.Количество() = 0, "", СписокВыбора[0].Значение);

		СписокВыбора = ПолучитьСписокСвязейПоВладельцу(ЗагружаемыйРеквизит.ОписаниеТипов, ТЗ);
		ЗагружаемыйРеквизит.LinkByOwner = ?(СписокВыбора.Количество() = 0, "", СписокВыбора[0].Значение);

		СписокВыбора = ПолучитьСписокСвязейПоТипу(ЗагружаемыйРеквизит, ТЗ);
		Если СписокВыбора.Количество() = 0 Тогда
			ЗагружаемыйРеквизит.LinkByType = "";
			ЗагружаемыйРеквизит.LinkByTypeItem = 0;
		Иначе
			ЗагружаемыйРеквизит.LinkByType = СписокВыбора[0].Значение;
			Если Найти(ЗагружаемыйРеквизит.ИмяРеквизита, "3") <> 0 Тогда

				ЗагружаемыйРеквизит.LinkByTypeItem = 3;

			ElsIf Найти(ЗагружаемыйРеквизит.ИмяРеквизита, "2") <> 0 Тогда

				ЗагружаемыйРеквизит.LinkByTypeItem = 2;

			Иначе

				ЗагружаемыйРеквизит.LinkByTypeItem = 1;

			EndIf;

		EndIf;

		ЗагружаемыйРеквизит.DefaultValue = ЗагружаемыйРеквизит.TypeDescription.ПривестиЗначение(Undefined);
		ЗагружаемыйРеквизит.AvailableTypes = ЗагружаемыйРеквизит.TypeDescription;
		ЗагружаемыйРеквизит.ImportMode = "Искать";
	EndDo;

EndProcedure // ()

// Заполняет настройки колонок по умолчанию для справочника
//
&AtServer
Procedure ЗаполнитьНастройкиКолонокСправочника(ТЗ)

	МетаданныеИсточника = ПолучитьМетаданныеИсточника();

	Если МетаданныеИсточника = Undefined Тогда
		Return;
	EndIf;

	Если МетаданныеИсточника.ДлинаКода > 0 Тогда

		ЗагружаемыйРеквизит = ТЗ.Добавить();
		ЗагружаемыйРеквизит.AttributeName           = "Код";
		ЗагружаемыйРеквизит.AttributePresentation = "Код";
		ЗагружаемыйРеквизит.PossibleSearchField   =  True;

		Если МетаданныеИсточника.ТипКода = Метаданные.СвойстваОбъектов.ТипКодаСправочника.Строка Тогда
			ЗагружаемыйРеквизит.TypeDescription = Новый ОписаниеТипов("Строка", ,
				Новый КвалификаторыСтроки(МетаданныеИсточника.ДлинаКода));
		Иначе
			ЗагружаемыйРеквизит.TypeDescription = Новый ОписаниеТипов("Число", , ,
				Новый КвалификаторыЧисла(МетаданныеИсточника.ДлинаКода));
		EndIf;

	EndIf;

	Если МетаданныеИсточника.ДлинаНаименования > 0 Тогда

		ЗагружаемыйРеквизит = ТЗ.Добавить();
		ЗагружаемыйРеквизит.AttributeName           = "Наименование";
		ЗагружаемыйРеквизит.AttributePresentation = "Наименование";
		ЗагружаемыйРеквизит.PossibleSearchField   =  True;
		ЗагружаемыйРеквизит.TypeDescription = Новый ОписаниеТипов("Строка", ,
			Новый КвалификаторыСтроки(МетаданныеИсточника.ДлинаНаименования));

	EndIf;

	Если МетаданныеИсточника.Владельцы.Количество() > 0 Тогда

		ЗагружаемыйРеквизит = ТЗ.Добавить();
		ЗагружаемыйРеквизит.AttributeName           = "Владелец";
		ЗагружаемыйРеквизит.AttributePresentation = "Владелец";
		ЗагружаемыйРеквизит.PossibleSearchField   =  True;

		СтрокаОписанияТипов = "";

		Для Каждого Владелец Из МетаданныеИсточника.Владельцы Цикл
			СтрокаОписанияТипов = ?(ПустаяСтрока(СтрокаОписанияТипов), "", СтрокаОписанияТипов + ", ")
				+ Владелец.ПолноеИмя();
		EndDo;

		СтрокаОписанияТипов = СтрЗаменить(СтрокаОписанияТипов, ".", "Ссылка.");
		ЗагружаемыйРеквизит.TypeDescription = Новый ОписаниеТипов(СтрокаОписанияТипов);

	EndIf;

	Если МетаданныеИсточника.Иерархический Тогда

		ЗагружаемыйРеквизит = ТЗ.Добавить();
		ЗагружаемыйРеквизит.AttributeName           = "Родитель";
		ЗагружаемыйРеквизит.AttributePresentation = "Родитель";
		ЗагружаемыйРеквизит.PossibleSearchField   = True;
		ЗагружаемыйРеквизит.TypeDescription = Новый ОписаниеТипов(СтрЗаменить(МетаданныеИсточника.ПолноеИмя(), ".",
			"Ссылка."));
		
		Если МетаданныеИсточника.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов Тогда
			ЗагружаемыйРеквизит = ТЗ.Добавить();
			ЗагружаемыйРеквизит.AttributeName           = "ЭтоГруппа";
			ЗагружаемыйРеквизит.AttributePresentation = "ЭтоГруппа";
			ЗагружаемыйРеквизит.PossibleSearchField   = True;
			ЗагружаемыйРеквизит.TypeDescription = Новый ОписаниеТипов("Булево");
		EndIf; 

	EndIf;

	Для Каждого Реквизит Из МетаданныеИсточника.Реквизиты Цикл
		Если Не Реквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы Тогда
			ЗагружаемыйРеквизит                        = ТЗ.Добавить();
			ЗагружаемыйРеквизит.AttributeName           = Реквизит.Имя;
			ЗагружаемыйРеквизит.AttributePresentation = Реквизит.Представление();
			ЗагружаемыйРеквизит.PossibleSearchField   = Не Реквизит.Индексирование
				= Метаданные.СвойстваОбъектов.Индексирование.НеИндексировать;
			ЗагружаемыйРеквизит.TypeDescription = МетаданныеИсточника.Реквизиты[ЗагружаемыйРеквизит.AttributeName].Тип;
		EndIf;
	EndDo;

	Для Каждого ЗагружаемыйРеквизит Из ТЗ Цикл

		СписокВыбора = ПолучитьСписокИменПредставлений(ЗагружаемыйРеквизит.ОписаниеТипов);
		ЗагружаемыйРеквизит.SearchBy = ?(СписокВыбора.Количество() = 0, "", СписокВыбора[0].Значение);

		СписокВыбора = ПолучитьСписокСвязейПоВладельцу(ЗагружаемыйРеквизит.ОписаниеТипов, ТЗ);
		ЗагружаемыйРеквизит.LinkByOwner = ?(СписокВыбора.Количество() = 0, "", СписокВыбора[0].Значение);

		СписокВыбора = ПолучитьСписокСвязейПоТипу(ЗагружаемыйРеквизит, ТЗ);
		Если СписокВыбора.Количество() = 0 Тогда
			ЗагружаемыйРеквизит.LinkByType = "";
			ЗагружаемыйРеквизит.LinkByTypeItem = 0;
		Иначе
			ЗагружаемыйРеквизит.LinkByType = СписокВыбора[0].Значение;
			Если Найти(ЗагружаемыйРеквизит.ИмяРеквизита, "3") <> 0 Тогда

				ЗагружаемыйРеквизит.LinkByTypeItem = 3;

			ElsIf Найти(ЗагружаемыйРеквизит.ИмяРеквизита, "2") <> 0 Тогда

				ЗагружаемыйРеквизит.LinkByTypeItem = 2;

			Иначе

				ЗагружаемыйРеквизит.LinkByTypeItem = 1;

			EndIf;
		EndIf;

		ЗагружаемыйРеквизит.DefaultValue = ЗагружаемыйРеквизит.TypeDescription.ПривестиЗначение(Undefined);
		ЗагружаемыйРеквизит.AvailableTypes = ЗагружаемыйРеквизит.TypeDescription;
		ЗагружаемыйРеквизит.ImportMode = "Искать";
	EndDo;
EndProcedure // ()

// Заполняет настройки колонок по умолчанию для регистра сведений
//
&AtServer
Procedure ЗаполнитьНастройкиКолонокРегистраСведений(ТЗ)

	МетаданныеИсточника = ПолучитьМетаданныеИсточника();

	Если МетаданныеИсточника = Undefined Тогда
		Return;
	EndIf;

	Если Не МетаданныеИсточника.ПериодичностьРегистраСведений
		= Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда

		ЗагружаемыйРеквизит = ТЗ.Добавить();
		ЗагружаемыйРеквизит.AttributeName           = "Период";
		ЗагружаемыйРеквизит.AttributePresentation = "Период";
		ЗагружаемыйРеквизит.PossibleSearchField = True;
		ЗагружаемыйРеквизит.SearchField           = True;

		ЗагружаемыйРеквизит.TypeDescription = Новый ОписаниеТипов("Дата", , , ,
			Новый КвалификаторыДаты(ЧастиДаты.ДатаВремя));

	EndIf;

	Для Каждого Реквизит Из МетаданныеИсточника.Измерения Цикл
		ЗагружаемыйРеквизит                        = ТЗ.Добавить();
		ЗагружаемыйРеквизит.PossibleSearchField = True;
		ЗагружаемыйРеквизит.AttributeName           = Реквизит.Имя;
		ЗагружаемыйРеквизит.AttributePresentation = Реквизит.Представление();
		ЗагружаемыйРеквизит.TypeDescription = МетаданныеИсточника.Измерения[ЗагружаемыйРеквизит.AttributeName].Тип;
	EndDo;

	Для Каждого Реквизит Из МетаданныеИсточника.Ресурсы Цикл
		ЗагружаемыйРеквизит                        = ТЗ.Добавить();
		ЗагружаемыйРеквизит.AttributeName           = Реквизит.Имя;
		ЗагружаемыйРеквизит.AttributePresentation = Реквизит.Представление();
		ЗагружаемыйРеквизит.TypeDescription = МетаданныеИсточника.Ресурсы[ЗагружаемыйРеквизит.AttributeName].Тип;
	EndDo;

	Для Каждого Реквизит Из МетаданныеИсточника.Реквизиты Цикл
		ЗагружаемыйРеквизит                        = ТЗ.Добавить();
		ЗагружаемыйРеквизит.AttributeName           = Реквизит.Имя;
		ЗагружаемыйРеквизит.AttributePresentation = Реквизит.Представление();
		ЗагружаемыйРеквизит.TypeDescription = МетаданныеИсточника.Реквизиты[ЗагружаемыйРеквизит.AttributeName].Тип;
	EndDo;

	Для Каждого ЗагружаемыйРеквизит Из ТЗ Цикл

		СписокВыбора = ПолучитьСписокИменПредставлений(ЗагружаемыйРеквизит.ОписаниеТипов);
		ЗагружаемыйРеквизит.SearchBy = ?(СписокВыбора.Количество() = 0, "", СписокВыбора[0].Значение);

		СписокВыбора = ПолучитьСписокСвязейПоВладельцу(ЗагружаемыйРеквизит.ОписаниеТипов, ТЗ);
		ЗагружаемыйРеквизит.LinkByOwner = ?(СписокВыбора.Количество() = 0, "", СписокВыбора[0].Значение);

		СписокВыбора = ПолучитьСписокСвязейПоТипу(ЗагружаемыйРеквизит, ТЗ);
		Если СписокВыбора.Количество() = 0 Тогда
			ЗагружаемыйРеквизит.LinkByType = "";
			ЗагружаемыйРеквизит.LinkByTypeItem = 0;
		Иначе
			ЗагружаемыйРеквизит.LinkByType = СписокВыбора[0].Значение;
			Если Найти(ЗагружаемыйРеквизит.ИмяРеквизита, "3") <> 0 Тогда

				ЗагружаемыйРеквизит.LinkByTypeItem = 3;

			ElsIf Найти(ЗагружаемыйРеквизит.ИмяРеквизита, "2") <> 0 Тогда

				ЗагружаемыйРеквизит.LinkByTypeItem = 2;

			Иначе

				ЗагружаемыйРеквизит.LinkByTypeItem = 1;

			EndIf;
		EndIf;

		ЗагружаемыйРеквизит.DefaultValue = ЗагружаемыйРеквизит.TypeDescription.ПривестиЗначение(Undefined);
		ЗагружаемыйРеквизит.AvailableTypes = ЗагружаемыйРеквизит.TypeDescription;
		ЗагружаемыйРеквизит.ImportMode = "Искать";
	EndDo;
EndProcedure // ()

// Function формирует табличный документ с настройками обработки
&AtServer
Function ПолучитьНастройки()

	МетаданныеОбъекта = ПолучитьМетаданныеИсточника();

	Если МетаданныеОбъекта = Undefined Тогда
		Return Undefined;
	EndIf;

	ВидОбъекта     = МетаданныеОбъекта.ПолноеИмя();

	ДокументРезультат = Новый ТабличныйДокумент;
	ОбработкаОбъект = FormAttributeToValue("Object");
	Макет = ОбработкаОбъект.ПолучитьМакетОбработки("МакетСохраненияНастроек");

	ОбластьШапки = Макет.ПолучитьОбласть("Шапка");
	Если Object.ImportMode = 0 Тогда
		ОбластьШапки.Параметры.ImportMode = "в справочник";
	ElsIf Object.ImportMode = 1 Тогда
		ОбластьШапки.Параметры.ImportMode = "в табличную часть";
	ElsIf Object.ImportMode = 2 Тогда
		ОбластьШапки.Параметры.ImportMode = "в регистр сведений";
	EndIf;

	ОбластьШапки.Параметры.ВидОбъекта                                = ВидОбъекта;
	ОбластьШапки.Параметры.DontCreateNewItems                 = ?(Object.DontCreateNewItems, "Х", "");
	ОбластьШапки.Параметры.ReplaceExistingRecords                 = ?(Object.ReplaceExistingRecords, "Х", "");
	ОбластьШапки.Параметры.ManualSpreadsheetDocumentColumnsNumeration = ?(
		Object.ManualSpreadsheetDocumentColumnsNumeration, "Х", "");
	ОбластьШапки.Параметры.SpreadsheetDocumentFirstDataRow     = Object.SpreadsheetDocumentFirstDataRow;

	ДокументРезультат.Вывести(ОбластьШапки);

	ТЗ = FormAttributeToValue("ImportedAttributesTable");

	Для Каждого ЗагружаемыйРеквизит Из ТЗ Цикл
		ОбластьСтроки = Макет.ПолучитьОбласть("Строка" + ?(ЗагружаемыйРеквизит.ImportMode = "Вычислять", "Expression",
			""));

		ОбластьСтроки.Параметры.Check      = ?(ЗагружаемыйРеквизит.Пометка, "Х", "");
		ОбластьСтроки.Параметры.AttributeName = ЗагружаемыйРеквизит.AttributeName;
		ОбластьСтроки.Параметры.SearchField   = ?(ЗагружаемыйРеквизит.ПолеПоиска, "Х", "");

		ОбластьСтроки.Параметры.TypeDescription       = ПолучитьОписаниеТипа(ЗагружаемыйРеквизит.ОписаниеТипов);

		ОбластьСтроки.Параметры.ImportMode       = ЗагружаемыйРеквизит.ImportMode;
		Если ЗагружаемыйРеквизит.TypeDescription.ПривестиЗначение(Undefined) = ЗагружаемыйРеквизит.DefaultValue Тогда
			ОбластьСтроки.Параметры.DefaultValue = "";
		Иначе
			ОбластьСтроки.Параметры.DefaultValue = ЗначениеВСтрокуВнутр(ЗагружаемыйРеквизит.ЗначениеПоУмолчанию);
		EndIf;

		Если ЗагружаемыйРеквизит.ImportMode = "Вычислять" Тогда

			ОбластьСтроки.Параметры.Expression           = ЗагружаемыйРеквизит.Expression;

		Иначе
			ОбластьСтроки.Параметры.SearchBy            = ЗагружаемыйРеквизит.SearchBy;
			ОбластьСтроки.Параметры.LinkByOwner    = ?(ТипЗнч(ЗагружаемыйРеквизит.СвязьПоВладельцу) = Тип(
				"Строка"), ЗагружаемыйРеквизит.СвязьПоВладельцу, ЗначениеВСтрокуВнутр(
				ЗагружаемыйРеквизит.СвязьПоВладельцу));
			ОбластьСтроки.Параметры.LinkByType         = ?(ТипЗнч(ЗагружаемыйРеквизит.СвязьПоТипу) = Тип("Строка"),
				ЗагружаемыйРеквизит.СвязьПоТипу, ЗначениеВСтрокуВнутр(ЗагружаемыйРеквизит.СвязьПоТипу));
			ОбластьСтроки.Параметры.LinkByTypeItem  = ЗагружаемыйРеквизит.LinkByTypeItem;
		EndIf;
		// Добавлен параметр ColumnNumber
		ОбластьСтроки.Параметры.ColumnNumber			= ЗагружаемыйРеквизит.ColumnNumber;

		ДокументРезультат.Вывести(ОбластьСтроки);

	EndDo;

	ОбластьПодвала = Макет.ПолучитьОбласть("Events");
	ОбластьПодвала.Параметры.BeforeWriteObject = Object.BeforeWriteObject;
	ОбластьПодвала.Параметры.OnWriteObject = Object.OnWriteObject;
	ДокументРезультат.Вывести(ОбластьПодвала);
	Если Object.ImportMode Тогда

		ОбластьПодвала = Макет.ПолучитьОбласть("СобытияПослеДобавленияСтроки");
		ОбластьПодвала.Параметры.AfterAddRow = Object.AfterAddRow;
		ДокументРезультат.Вывести(ОбластьПодвала);

	EndIf;

	Return ДокументРезультат;

EndFunction

// Function читает mxl-файл с настройками обработки
&AtServer
Function ПрочитатьНастройкиНаСервере(АдресХранилища)

	Данные = ПолучитьИзВременногоХранилища(АдресХранилища);

	ИмяФайлаВременное = ПолучитьИмяВременногоФайла("mxl");
	ВремДок = Новый ТабличныйДокумент;
	Данные.Записать(ИмяФайлаВременное);
	ВремДок.Прочитать(ИмяФайлаВременное);
	УдалитьФайлы(ИмяФайлаВременное);

	Return ВремДок;
EndFunction

// Function возвращает содержимое mxl-файла с настройками обработки
&НаКлиенте
Function мПрочитатьНастройкиИзФайла(ИмяФайла)

	ДанныеФайла = Новый ДвоичныеДанные(ИмяФайла);

	АдресФайла = "";
	АдресФайла = ПоместитьВоВременноеХранилище(ДанныеФайла, ЭтаФорма.УникальныйИдентификатор);

	Return ПрочитатьНастройкиНаСервере(АдресФайла);

EndFunction

&AtServer
Procedure СкопироватьНастройки(Знач Источник, Приемник)
	
	//Если ТипЗнч(Источник) = Тип("ДанныеФормыКоллекция") Тогда
	//	Источник = ДанныеФормыВЗначение(Источник, Тип("ТаблицаЗначений"));
	//Иначе
	Если Не ТипЗнч(Источник) = Тип("ТаблицаЗначений") Тогда
		Return;
	EndIf;

	Приемник.Очистить();

	Для Каждого Стр Из Источник Цикл
		НовСтр = Приемник.Добавить();
		ЗаполнитьЗначенияСвойств(НовСтр, Стр);
	EndDo;

EndProcedure

&AtServer
Procedure ПриЗакрытииНаСервере()

	мСохранитьЗначение("ImportMode", Object.ImportMode);
	мСохранитьЗначение("SourceRef", Object.SourceRef);
	мСохранитьЗначение("SourceTabularSection", Object.SourceTabularSection);
	мСохранитьЗначение("RegisterTypeName", Object.RegisterTypeName);
	мСохранитьЗначение("CatalogObjectType", Object.CatalogObjectType);

EndProcedure // ПриЗакрытииНаСервере()

////////////////////////////////////////////////////////////////////////////////
//

&AtServer
Procedure ОбновитьДанныеТабличногоДокументаСервер()

	SpreadsheetDocument.Очистить();

	СформироватьСтруктуруКолонок();
	СформироватьШапкуТабличногоДокумента(SpreadsheetDocument);

	НомерСтроки = Object.SpreadsheetDocumentFirstDataRow;

	МетаданныеИсточника = ПолучитьМетаданныеИсточника();
	Если Object.ImportMode = 0 Или Object.ImportMode = 2 Или МетаданныеИсточника = Undefined Тогда
		Return;
	EndIf;

	Источник = Object.SourceRef[Object.SourceTabularSection];
	
	//ТЗ = FormAttributeToValue("ImportedAttributesTable");

	Для Каждого Строка Из Источник Цикл

		НомерКолонки = 0;

		Для Каждого ЗагружаемыйРеквизит Из ImportedAttributesTable Цикл

			Если ЗагружаемыйРеквизит.Check Тогда

				Если Object.ManualSpreadsheetDocumentColumnsNumeration Тогда
					НомерКолонки = ЗагружаемыйРеквизит.ColumnNumber;
				Иначе
					НомерКолонки = НомерКолонки + 1;
				EndIf;

				Область = SpreadsheetDocument.Область("R" + Формат(НомерСтроки, "ЧГ=") + "C" + НомерКолонки);
				Значение = Строка[ЗагружаемыйРеквизит.AttributeName];

				Try
					Представление = Значение[ЗагружаемыйРеквизит.SearchBy];

				Исключение

					Представление = Значение;

				EndTry;

				Область.Текст = Представление;
				Область.Расшифровка = Значение;

			EndIf;

		EndDo;

		НомерСтроки = НомерСтроки + 1;
	EndDo;

EndProcedure // ОбновитьДанныеТабличногоДокументаСервер()

&НаКлиенте
Procedure ОбновитьДанныеТабличногоДокумента(Знач Оповещение, БезВопросов = False)

	Если (Object.ImportMode = 0 Или Object.ImportMode = 2) И Элементы.SpreadsheetDocument.Высота > 1 И Не БезВопросов Тогда
		ПоказатьВопрос(Новый ОписаниеОповещения("ОбновитьДанныеТабличногоДокументаЗавершение", ЭтаФорма,
			Новый Структура("Оповещение", Оповещение)), "Табличный документ содержит данные. Очистить?",
			РежимДиалогаВопрос.ДаНет);
		Return;
	Иначе
		ОбновитьДанныеТабличногоДокументаСервер();
	EndIf;

	ОбновитьДанныеТабличногоДокументаФрагмент(Оповещение);
EndProcedure

&НаКлиенте
Procedure ОбновитьДанныеТабличногоДокументаЗавершение(РезультатВопроса, ДополнительныеПараметры) Экспорт

	Оповещение = ДополнительныеПараметры.Оповещение;
	Если РезультатВопроса = КодReturnаДиалога.Да Тогда
		ОбновитьДанныеТабличногоДокументаСервер();
		ВыполнитьОбработкуОповещения(Оповещение);
		Return;
	EndIf;

	ОбновитьДанныеТабличногоДокументаФрагмент(Оповещение);

EndProcedure

&НаКлиенте
Procedure ОбновитьДанныеТабличногоДокументаФрагмент(Знач Оповещение)

	ВыполнитьОбработкуОповещения(Оповещение);

EndProcedure

// Function считывает в табличный документ данные из файла в формате Excel
//
// Параметры:
//  SpreadsheetDocument  - SpreadsheetDocument, в который необходимо прочитать данные
//  ИмяФайла           - имя файла в формате Excel, из которого необходимо прочитать данные
//  НомерЛистаExcel    - номер листа книги Excel, из которого необходимо прочитать данные
//
// Возвращаемое значение:
//  True, если файл прочитан, False - иначе
//
&НаКлиенте
Procedure мПрочитатьТабличныйДокументИзExcel(ИмяФайла, НомерЛистаExcel = 1) Экспорт

	НачатьПроверкуСуществованияФайла(ИмяФайла,
		Новый ОписаниеОповещения("мПрочитатьТабличныйДокументИзExcelЗаверешениеПроверкиСуществованияФайла", ЭтотОбъект,
		Новый Структура("ИмяФайла,НомерЛистаExcel", ИмяФайла, НомерЛистаExcel)));

EndProcedure // ()

&НаКлиенте
Procedure мПрочитатьТабличныйДокументИзExcelЗаверешениеПроверкиСуществованияФайла(Существует, ДополнительныеПараметры) Экспорт
	Если Не Существует Тогда
		Сообщить("Файл не существует!");
		Return;
	EndIf;
	НомерЛистаExcel=ДополнительныеПараметры.НомерЛистаExcel;
	ИмяФайла=ДополнительныеПараметры.ИмяФайла;

	xlLastCell = 11;
	Try
		Excel = Новый COMОбъект("Excel.Application");
		Excel.WorkBooks.Open(ИмяФайла);
		Сообщить("Обработка файла Microsoft Excel...");
		ExcelЛист = Excel.Sheets(НомерЛистаExcel);
	Исключение
		Сообщить("Ошибка. Возможно неверно указан номер листа книги Excel.");
		Return;

	EndTry;

	SpreadsheetDocument = Новый ТабличныйДокумент;

	ActiveCell = Excel.ActiveCell.SpecialCells(xlLastCell);
	RowCount = ActiveCell.Row;
	ColumnCount = ActiveCell.Column;
	Для Column = 1 По ColumnCount Цикл
		SpreadsheetDocument.Область("C" + Формат(Column, "ЧГ=")).ColumnWidth = ExcelЛист.Columns(Column).ColumnWidth;
	EndDo;
	Для Row = 1 По RowCount Цикл

		Для Column = 1 По ColumnCount Цикл
			SpreadsheetDocument.Область("R" + Формат(Row, "ЧГ=") + "C" + Формат(Column, "ЧГ=")).Текст = ExcelЛист.Cells(
				Row, Column).Text;
		EndDo;

	EndDo;

	Excel.WorkBooks.Close();
	Excel = 0;
EndProcedure

// Function считывает в табличный документ данные из файла в формате TXT
//
// Параметры:
//  SpreadsheetDocument  - SpreadsheetDocument, в который необходимо прочитать данные
//  ИмяФайла           - имя файла в формате TXT, из которого необходимо прочитать данные
//
// Возвращаемое значение:
//  True, если файл прочитан, False - иначе
//
&НаКлиенте
Procedure мПрочитатьТабличныйДокументИзТекста(ИмяФайла) Экспорт

	ВыбФайл = Новый Файл(ИмяФайла);
	ВыбФайл.НачатьПроверкуСуществования(
		Новый ОписаниеОповещения("мПрочитатьТабличныйДокументИзТекстаЗавершениеПроверкиСуществованияФайла", ЭтаФорма,
		Новый Структура("ИмяФайла", ИмяФайла)));

EndProcedure

&НаКлиенте
Procedure мПрочитатьТабличныйДокументИзТекстаЗавершениеПроверкиСуществованияФайла(Существует, ДополнительныеПараметры) Экспорт

	ИмяФайла = ДополнительныеПараметры.ИмяФайла;
	Если Существует Тогда
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.НачатьЧтение(Новый ОписаниеОповещения("мПрочитатьТабличныйДокументИзТекстаЗавершение",
			ЭтотОбъект, Новый Структура("ТекстовыйДокумент", ТекстовыйДокумент),
			"мПрочитатьТабличныйДокументИзТекстаЗавершениеОшибкаЧтения", ЭтотОбъект), ИмяФайла);

	Иначе
		Сообщить("Файл не существует!");

	EndIf;

EndProcedure // ()

&НаКлиенте
Procedure мПрочитатьТабличныйДокументИзТекстаЗавершение(ДополнительныеПараметры) Экспорт
	ТекстовыйДокумент=ДополнительныеПараметры.ТекстовыйДокумент;

	SpreadsheetDocument = Новый ТабличныйДокумент;
	Для ТекущаяСтрока = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		ТекущаяКолонка = 0;
		Для Каждого Значение Из mSplitStringIntoSubstringsArray(ТекстовыйДокумент.ПолучитьСтроку(ТекущаяСтрока),
			Символы.Таб) Цикл
			ТекущаяКолонка = ТекущаяКолонка + 1;
			SpreadsheetDocument.Область("R" + Формат(ТекущаяСтрока, "ЧГ=") + "C" + Формат(ТекущаяКолонка,
				"ЧГ=")).Текст = Значение;

		EndDo;

	EndDo;
EndProcedure

&НаКлиенте
Procedure мПрочитатьТабличныйДокументИзТекстаЗавершениеОшибкаЧтения(ИнформацияОбОшибке, СтандартнаяОбработка,
	ДополнительныеПараметры) Экспорт
	СтандартнаяОбработка=False;
	Сообщить("Ошибка открытия файла!");
EndProcedure

&НаКлиенте
Procedure НачатьПроверкуСуществованияФайла(ИмяФайла, ОписаниеОповещенияОЗавершении)
	ВыбФайл = Новый Файл(ИмяФайла);
	ВыбФайл.НачатьПроверкуСуществования(ОписаниеОповещенияОЗавершении);
EndProcedure

// Function считывает в табличный документ данные из файла в формате dBase III (*.dbf)
//
// Параметры:
//  SpreadsheetDocument  - SpreadsheetDocument, в который необходимо прочитать данные
//  ИмяФайла           - имя файла в формате TXT, из которого необходимо прочитать данные
//
// Возвращаемое значение:
//  True, если файл прочитан, False - иначе
//
&НаКлиенте
Procedure мПрочитатьТабличныйДокументИзDBF(ИмяФайла) Экспорт
	НачатьПроверкуСуществованияФайла(ИмяФайла,
		Новый ОписаниеОповещения("мПрочитатьТабличныйДокументИзDBFЗавершениеПроверкиСуществованияФайла", ЭтотОбъект,
		Новый Структура("ИмяФайла", ИмяФайла)));
EndProcedure // ()

&НаКлиенте
Procedure мПрочитатьТабличныйДокументИзDBFЗавершениеПроверкиСуществованияФайла(Существует, ДополнительныеПараметры) Экспорт
	Если Не Существует Тогда
		Сообщить("Файл не существует!");
		Return;
	EndIf;

#Если Не ВебКлиент Тогда

	ИмяФайла=ДополнительныеПараметры.ИмяФайла;

	XBase  = Новый XBase;
	XBase.Кодировка = ПредопределенноеЗначение("КодировкаXBase.OEM");
	Try
		XBase.ОткрытьФайл(ИмяФайла);
	Исключение
		Сообщить("Ошибка открытия файла!");
		Return;
	EndTry;

	SpreadsheetDocument = Новый ТабличныйДокумент;
	ТекущаяСтрока = 1;
	ТекущаяКолонка = 0;
	Для Каждого Поле Из XBase.поля Цикл
		ТекущаяКолонка = ТекущаяКолонка + 1;
		SpreadsheetDocument.Область("R" + Формат(ТекущаяСтрока, "ЧГ=") + "C" + Формат(ТекущаяКолонка,
			"ЧГ=")).Текст = Поле.Имя;
	EndDo;
	Рез = XBase.Первая();
	Пока Не XBase.ВКонце() Цикл
		ТекущаяСтрока = ТекущаяСтрока + 1;

		ТекущаяКолонка = 0;
		Для Каждого Поле Из XBase.поля Цикл
			ТекущаяКолонка = ТекущаяКолонка + 1;
			SpreadsheetDocument.Область("R" + Формат(ТекущаяСтрока, "ЧГ=") + "C" + Формат(ТекущаяКолонка,
				"ЧГ=")).Текст = XBase.ПолучитьЗначениеПоля(ТекущаяКолонка - 1);
		EndDo;

		XBase.Следующая();
	EndDo;
#Иначе
		ПоказатьПредупреждение(Undefined, "Чтение DBF файлов недоступно в веб клиенте");
#EndIf

EndProcedure

&AtServer
Procedure ПрочитатьТабличныйДокументИзMXLНаСервере(АдресХранилища)

	Данные = ПолучитьИзВременногоХранилища(АдресХранилища);

	ИмяФайлаВременное = ПолучитьИмяВременногоФайла("mxl");

	Данные.Записать(ИмяФайлаВременное);
	SpreadsheetDocument.Прочитать(ИмяФайлаВременное);
	УдалитьФайлы(ИмяФайлаВременное);

EndProcedure // ПрочитатьТабличныйДокументИзMXLНаСервере()

&НаКлиенте
Procedure мПрочитатьТабличныйДокументИзMXL(ИмяФайла)

	ДанныеФайла = Новый ДвоичныеДанные(ИмяФайла);

	АдресФайла = "";
	АдресФайла = ПоместитьВоВременноеХранилище(ДанныеФайла, ЭтаФорма.УникальныйИдентификатор);

	ПрочитатьТабличныйДокументИзMXLНаСервере(АдресФайла);

EndProcedure // ()

////////////////////////////////////////////////////////////////////////////////
//

&НаКлиенте
Procedure УправлениеВидимостью()

	РежимЗагрузки = Object.ImportMode;
	РучнаяНумерацияКолонокТабличногоДокумента = Object.ManualSpreadsheetDocumentColumnsNumeration;

	Если РежимЗагрузки = 0 Тогда
		ТекЭлемент = Элементы.ImportToCatalogGroup;
	ElsIf РежимЗагрузки = 1 Тогда
		ТекЭлемент = Элементы.ImportToTabularSectionGroup;
	ElsIf РежимЗагрузки = 2 Тогда
		ТекЭлемент = Элементы.ImportToInformationRegisterGroup;
	Иначе
		Return; // Неизвестный режим
	EndIf;
	Если Не Элементы.ModeBarGroup.ТекущаяСтраница = ТекЭлемент Тогда
		Элементы.ModeBarGroup.ТекущаяСтраница = ТекЭлемент;
	EndIf;

	Элементы.ImportedAttributesTableSearchField.Видимость         = РежимЗагрузки = 0;

	Элементы.DontCreateNewItems.Видимость = РежимЗагрузки = 0;
	Элементы.ReplaceExistingRecords.Видимость = РежимЗагрузки = 2;

	ДоступностьКнопкиСохранитьЗначения    = ЕстьВыбранныеМетаданные();
	ДоступностьКнопкиВосстановитьЗначения = False; //Не СписокСохраненныхНастроек.Количество() = 0;

	Элементы.SaveValues.Доступность = False; //ДоступностьКнопкиСохранитьЗначения;
	Элементы.RestoreValues.Доступность = ДоступностьКнопкиВосстановитьЗначения;

	Элементы.SaveValuesToFile.Доступность = ДоступностьКнопкиСохранитьЗначения;

	Элементы.ImportedAttributesTableColumnNumber.Видимость = РучнаяНумерацияКолонокТабличногоДокумента;
	Элементы.RenumberColumns.Доступность = РучнаяНумерацияКолонокТабличногоДокумента;
	Элементы.ManualSpreadsheetDocumentColumnsNumeration.Check = РучнаяНумерацияКолонокТабличногоДокумента;

EndProcedure // УправлениеВидимостью()

// Procedure выполняет установку реквизитов, связанных с источником данных
//
&AtServer
Procedure УстановитьИсточник(СписокНастроек = Undefined)

	Источник        = Undefined;
	ОбъектИсточника = Undefined;
	//СписокСохраненныхНастроек.Очистить();
	ПрошлыйМетаданныеСсылкиИсточника = Undefined;
	МетаданныеИсточника = ПолучитьМетаданныеИсточника();
	Если МетаданныеИсточника = Undefined Тогда
		ImportedAttributesTable.Очистить();
	Иначе
		Врем = мВосстановитьЗначение(МетаданныеИсточника.ПолноеИмя());
		//Если НЕ СписокНастроек = Undefined Тогда
		//	СкопироватьНастройки(Врем, СписокНастроек);
		//	Настройка = ПолучитьНастройкуПоУмолчанию(СписокНастроек);
		//	ВосстановитьНастройкиИзСписка(Настройка);
		//Иначе
		//	ВосстановитьНастройкиИзСписка(Undefined);
		ЗаполнитьНастройкиКолонок(Undefined);
		//EndIf;
	EndIf;

	ОбновитьДанныеТабличногоДокументаСервер();

	СпискиВыбораСвязиПоВладельцу.Очистить();

	ТЗ = FormAttributeToValue("ImportedAttributesTable");

	Для Каждого ЗагружаемыйРеквизит Из ТЗ Цикл

		СтрокаСписка = СпискиВыбораСвязиПоВладельцу.Добавить();
		СтрокаСписка.AttributeName = ЗагружаемыйРеквизит.AttributeName;
		СтрокаСписка.СписокВыбора = ПолучитьСписокСвязейПоВладельцу(ЗагружаемыйРеквизит.ОписаниеТипов, ТЗ);
	EndDo;

EndProcedure

// Procedure выполняет инициализацию служебных переменных и констант модуля
//
&AtServer
Procedure Инициализация()

	Object.AdditionalProperties = Новый Структура;

	Object.AdditionalProperties.Вставить("ПримитивныеТипы", Новый Структура("Число, Строка, Дата, Булево", Тип(
		"Число"), Тип("Строка"), Тип("Дата"), Тип("Булево")));

	Если Object.SpreadsheetDocumentFirstDataRow < 2 Тогда
		Object.SpreadsheetDocumentFirstDataRow = 2;
	EndIf;

	Object.AdditionalProperties.Вставить("Колонки", Новый Структура);

EndProcedure // ()

///////////////////////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ КОМАНД

&НаКлиенте
Procedure ImportCommand(Команда)

	СтруктураТекстВопроса = ПолучитьТекстВопросаИсточника();
	КоличествоЭлементов = SpreadsheetDocument.ВысотаТаблицы - Object.SpreadsheetDocumentFirstDataRow + 1;
	Если Не ПустаяСтрока(СтруктураТекстВопроса.Ошибка) Тогда
		ПоказатьПредупреждение( , СтруктураТекстВопроса.Ошибка, , "Ошибка при загрузке!");
	Иначе
		ПоказатьВопрос(Новый ОписаниеОповещения("КомандаЗагрузитьЗавершение", ЭтаФорма), "Import "
			+ КоличествоЭлементов + СтруктураТекстВопроса.ТекстВопроса, РежимДиалогаВопрос.ДаНет);
	EndIf;

EndProcedure

&НаКлиенте
Procedure КомандаЗагрузитьЗавершение(РезультатВопроса, ДополнительныеПараметры) Экспорт

	Если РезультатВопроса = КодReturnаДиалога.Да Тогда
		ОчиститьСообщения();
		ЗагрузитьДанныеСервер();
	EndIf;

EndProcedure
&НаКлиенте
Procedure OpenCommand(Команда)

	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);

	ДиалогВыбораФайла.Заголовок = "Прочитать табличный документ из файла";
	ДиалогВыбораФайла.Фильтр    = "Табличный документ (*.mxl)|*.mxl|Лист Excel (*.xls,*.xlsx)|*.xls;*.xlsx|Текстовый документ (*.txt)|*.txt|dBase III (*.dbf)|*.dbf|";
	ДиалогВыбораФайла.Показать(Новый ОписаниеОповещения("КомандаОткрытьЗавершение", ЭтаФорма,
		Новый Структура("ДиалогВыбораФайла", ДиалогВыбораФайла)));

EndProcedure

&НаКлиенте
Procedure КомандаОткрытьЗавершение(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт

	ДиалогВыбораФайла = ДополнительныеПараметры.ДиалогВыбораФайла;
	Если (ВыбранныеФайлы <> Undefined) Тогда

		SpreadsheetDocument = Элементы.SpreadsheetDocument;
		ФайлНаДиске = Новый Файл(ДиалогВыбораФайла.ПолноеИмяФайла);
		Если нРег(ФайлНаДиске.Расширение) = ".mxl" Тогда
			мПрочитатьТабличныйДокументИзMXL(ДиалогВыбораФайла.ПолноеИмяФайла);
		ElsIf нРег(ФайлНаДиске.Расширение) = ".xls" Или нРег(ФайлНаДиске.Расширение) = ".xlsx" Тогда
			мПрочитатьТабличныйДокументИзExcel(ДиалогВыбораФайла.ПолноеИмяФайла);
		ElsIf нРег(ФайлНаДиске.Расширение) = ".txt" Тогда
			мПрочитатьТабличныйДокументИзТекста(ДиалогВыбораФайла.ПолноеИмяФайла);
		ElsIf нРег(ФайлНаДиске.Расширение) = ".dbf" Тогда
			мПрочитатьТабличныйДокументИзDBF(ДиалогВыбораФайла.ПолноеИмяФайла);
		EndIf;
		УправлениеВидимостью();
	EndIf;

EndProcedure

&НаКлиенте
Procedure SaveCommand(Команда)

	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);

	ДиалогВыбораФайла.Заголовок = "Сохранить табличный документ в файл";
	ДиалогВыбораФайла.Фильтр    = "Табличный документ (*.mxl)|*.mxl|Лист Excel (*.xls)|*.xls|Текстовый документ (*.txt)|*.txt|";
	ДиалогВыбораФайла.Показать(Новый ОписаниеОповещения("КомандаСохранитьЗавершение", ЭтаФорма,
		Новый Структура("ДиалогВыбораФайла", ДиалогВыбораФайла)));

EndProcedure

&НаКлиенте
Procedure КомандаСохранитьЗавершение(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт

	ДиалогВыбораФайла = ДополнительныеПараметры.ДиалогВыбораФайла;
	Если (ВыбранныеФайлы <> Undefined) Тогда

		SpreadsheetDocument = Элементы.SpreadsheetDocument;
		ФайлНаДиске = Новый Файл(ДиалогВыбораФайла.ПолноеИмяФайла);
		Если нРег(ФайлНаДиске.Расширение) = ".mxl" Тогда
			SpreadsheetDocument.НачатьЗапись(Undefined, ДиалогВыбораФайла.ПолноеИмяФайла,
				ТипФайлаТабличногоДокумента.MXL);
		ElsIf нРег(ФайлНаДиске.Расширение) = ".xls" Тогда
			SpreadsheetDocument.НачатьЗапись(Undefined, ДиалогВыбораФайла.ПолноеИмяФайла,
				ТипФайлаТабличногоДокумента.XLS);
		ElsIf нРег(ФайлНаДиске.Расширение) = ".txt" Тогда
			SpreadsheetDocument.НачатьЗапись(Undefined, ДиалогВыбораФайла.ПолноеИмяФайла,
				ТипФайлаТабличногоДокумента.TXT);
		EndIf;

	EndIf;

EndProcedure

&НаКлиенте
Procedure RefreshCommand(Команда)
	ОбновитьДанныеТабличногоДокумента(Undefined);
EndProcedure

&НаКлиенте
Procedure FillControlCommand(Команда)
	КонтрольЗаполненияСервер();
EndProcedure

&НаКлиенте
Procedure NextNoteCommand(Команда)
	
	//SpreadsheetDocument = Элементы.SpreadsheetDocument;

	Нашли = False;

	Колонка = SpreadsheetDocument.ТекущаяОбласть.Лево + 1;
	Строка  = SpreadsheetDocument.ТекущаяОбласть.Верх;

	Пока Не Нашли И Строка <= SpreadsheetDocument.ВысотаТаблицы Цикл

		Пока Не Нашли И Колонка <= SpreadsheetDocument.ШиринаТаблицы Цикл

			Область = SpreadsheetDocument.Область("R" + Формат(Строка, "ЧГ=") + "C" + Формат(Колонка, "ЧГ="));
			Нашли = Не ПустаяСтрока(Область.Примечание.Текст);

			Колонка = Колонка + 1;
		EndDo;
		Строка = Строка + 1;
		Колонка = 1;
	EndDo;

	Если Нашли Тогда
		SpreadsheetDocument.ТекущаяОбласть = Область;
	Иначе
		Сообщить("Достигнут конец документа", СтатусСообщения.Информация);
	EndIf;

EndProcedure

&НаКлиенте
Procedure PreviousNoteCommand(Команда)
	
	//SpreadsheetDocument = Элементы.SpreadsheetDocument;

	Нашли = False;

	Колонка = SpreadsheetDocument.ТекущаяОбласть.Лево - 1;
	Строка  = SpreadsheetDocument.ТекущаяОбласть.Верх;

	Пока Не Нашли И Строка > 0 Цикл

		Пока Не Нашли И Колонка > 0 Цикл

			Область = SpreadsheetDocument.Область("R" + Формат(Строка, "ЧГ=") + "C" + Формат(Колонка, "ЧГ="));
			Нашли = Не ПустаяСтрока(Область.Примечание.Текст);

			Колонка = Колонка - 1;
		EndDo;
		Строка = Строка - 1;
		Колонка = SpreadsheetDocument.ШиринаТаблицы;
	EndDo;

	Если Нашли Тогда
		SpreadsheetDocument.ТекущаяОбласть = Область;
	Иначе
		Сообщить("Достигнуто начало документа", СтатусСообщения.Информация);
	EndIf;

EndProcedure

&НаКлиенте
Procedure RestoreValuesFromFileCommand(Команда)

	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	ДиалогВыбораФайла.Заголовок	= "Восстановить значения из файла";
	ДиалогВыбораФайла.Фильтр	= "Настройка загрузки в табличный документ (*.mxlz)|*.mxlz|Все файлы (*.*)|*.*|";

	ДиалогВыбораФайла.Показать(Новый ОписаниеОповещения("КомандаВосстановитьЗначенияИзФайлаЗавершение1", ЭтаФорма,
		Новый Структура("ДиалогВыбораФайла", ДиалогВыбораФайла)));

EndProcedure

&НаКлиенте
Procedure КомандаВосстановитьЗначенияИзФайлаЗавершение1(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт

	ДиалогВыбораФайла = ДополнительныеПараметры.ДиалогВыбораФайла;
	Если (ВыбранныеФайлы <> Undefined) Тогда
		Настройки = мПрочитатьНастройкиИзФайла(ДиалогВыбораФайла.ПолноеИмяФайла);
		ЗаполнитьНастройкиКолонок(Настройки);
		УстановитьСписокТабличныхЧастей();
		ОбновитьДанныеТабличногоДокумента(Новый ОписаниеОповещения("КомандаВосстановитьЗначенияИзФайлаЗавершение",
			ЭтаФорма), True);
	Иначе
		КомандаВосстановитьЗначенияИзФайлаФрагмент();
	EndIf;

EndProcedure

&НаКлиенте
Procedure КомандаВосстановитьЗначенияИзФайлаЗавершение(Результат, ДополнительныеПараметры) Экспорт

	КомандаВосстановитьЗначенияИзФайлаФрагмент();

EndProcedure

&НаКлиенте
Procedure КомандаВосстановитьЗначенияИзФайлаФрагмент()

	УправлениеВидимостью();

EndProcedure

&НаКлиенте
Procedure SaveValuesToFileCommand(Команда)

	Настройки = ПолучитьНастройки();
	Если Настройки = Undefined Тогда
		Return;
	EndIf;

	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Сохранение);

	ДиалогВыбораФайла.Заголовок = "Сохранить значения настройки в файл";
	ДиалогВыбораФайла.Фильтр    = "Настройка загрузки в табличный документ (*.mxlz)|*.mxlz|Все файлы (*.*)|*.*|";
	ДиалогВыбораФайла.Показать(Новый ОписаниеОповещения("КомандаСохранитьЗначенияВФайлЗавершение", ЭтаФорма,
		Новый Структура("ДиалогВыбораФайла, Настройки", ДиалогВыбораФайла, Настройки)));

EndProcedure

&НаКлиенте
Procedure КомандаСохранитьЗначенияВФайлЗавершение(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт

	ДиалогВыбораФайла = ДополнительныеПараметры.ДиалогВыбораФайла;
	Настройки = ДополнительныеПараметры.Настройки;
	Если (ВыбранныеФайлы <> Undefined) Тогда

		Настройки.НачатьЗапись(Undefined, ДиалогВыбораФайла.ПолноеИмяФайла);

	EndIf;

EndProcedure

&НаКлиенте
Procedure RestoreValuesCommand(Команда)

	ФормаВыбораНастройки = ПолучитьФорму(DataProcessorID() + ".Форма.ФормаВыбораНастройки", , ЭтаФорма);
	ФормаВыбораНастройки.СписокНастроек = СписокСохраненныхНастроек;
	ТекущиеДанные = ФормаВыбораНастройки.Открыть();
	Если Не ТекущиеДанные = Undefined Тогда
		ЗаполнитьНастройкиКолонок(ТекущиеДанные.Значение);
	EndIf;

	мСохранитьЗначение(DataProcessorID(), ФормаВыбораНастройки.СписокНастроек);

EndProcedure

&НаКлиенте
Procedure SaveValuesCommand(Команда)

	ФормаСохраненияНастройки = ПолучитьФорму(DataProcessorID() + ".Форма.ФормаСохраненияНастройки", , ЭтаФорма);
	Если Не СписокСохраненныхНастроек.Количество() = 0 Тогда
		//ФормаСохраненияНастройки.СписокНастроек = СписокСохраненныхНастроек;
		Для Каждого Стр Из СписокСохраненныхНастроек Цикл

			НовСтр = ФормаСохраненияНастройки.СписокНастроек.Добавить();
			НовСтр.Check = Стр.Check;
			НовСтр.Представление = Стр.Представление;

		EndDo;
	EndIf;

	ТекущиеДанные = ФормаСохраненияНастройки.Открыть();

	Если Не ТекущиеДанные = Undefined Тогда
		
		//ПолучитьНастройкиСписком(ТекущиеДанные.Значение);
		//СкопироватьНастройки(ФормаСохраненияНастройки.СписокНастроек);
		//УстановитьТекущиеНастройки(СписокСохраненныхНастроек, ТекущиеДанные.Check, ТекущиеДанные.Представление, ПолучитьСтруктуруНастроек());
		мСохранитьЗначение(DataProcessorID(), СписокСохраненныхНастроек);

	EndIf;

EndProcedure

&НаКлиенте
Procedure RereadCommand(Команда)
	ЗаполнитьНастройкиКолонок(Undefined);
EndProcedure

&НаКлиенте
Procedure CheckAllCommand(Команда)
	Для Каждого ЗагружаемыйРеквизит Из ImportedAttributesTable Цикл
		ЗагружаемыйРеквизит.Check = True;
	EndDo;
EndProcedure

&НаКлиенте
Procedure UncheckAllCommand(Команда)
	Для Каждого ЗагружаемыйРеквизит Из ImportedAttributesTable Цикл
		ЗагружаемыйРеквизит.Check = False;
	EndDo;
EndProcedure

&НаКлиенте
Procedure ManualSpreadsheetDocumentColumnsNumerationCommand(Команда)
	Элементы.ManualSpreadsheetDocumentColumnsNumeration.Check = Не Элементы.ManualSpreadsheetDocumentColumnsNumeration.Check;
	Object.ManualSpreadsheetDocumentColumnsNumeration = Элементы.ManualSpreadsheetDocumentColumnsNumeration.Check;
	УправлениеВидимостью();
EndProcedure

&НаКлиенте
Procedure RenumberColumnsCommand(Команда)
	НомерКолонки = 1;
	Для Каждого Реквизит Из ImportedAttributesTable Цикл
		Если Реквизит.Check Тогда
			Если Не Реквизит.ColumnNumber = НомерКолонки Тогда
				Реквизит.ColumnNumber = НомерКолонки;
			EndIf;
			НомерКолонки = НомерКолонки + 1;
		Иначе
			Реквизит.ColumnNumber = 0;
		EndIf;

		Если Реквизит.ColumnNumber = 0 И Реквизит.ImportMode = "Искать" Тогда
			Реквизит.ImportMode = "Устанавливать";
		ElsIf Не Реквизит.ColumnNumber = 0 И Реквизит.ImportMode = "Устанавливать" Тогда
			Реквизит.ImportMode = "Искать";
		EndIf;

	EndDo;
EndProcedure

&НаКлиенте
Procedure EventsCommand(Команда)

	ФормаРедактированиеСобытий = ПолучитьФорму(DataProcessorID() + ".Форма.ФормаРедактированияСобытий", ,
		ЭтаФорма);

	ФормаРедактированиеСобытий.ImportMode = Object.ImportMode;

	ФормаРедактированиеСобытий.BeforeWriteObject.УстановитьТекст(Object.BeforeWriteObject);
	ФормаРедактированиеСобытий.OnWriteObject.УстановитьТекст(Object.OnWriteObject);
	ФормаРедактированиеСобытий.AfterAddRow.УстановитьТекст(Object.AfterAddRow);

	ФормаРедактированиеСобытий.Открыть();

	Если True = True Тогда

		Object.BeforeWriteObject   = ФормаРедактированиеСобытий.BeforeWriteObject.ПолучитьТекст();
		Object.OnWriteObject      = ФормаРедактированиеСобытий.OnWriteObject.ПолучитьТекст();
		Object.AfterAddRow = ФормаРедактированиеСобытий.AfterAddRow.ПолучитьТекст();

	EndIf;

EndProcedure

//@skip-warning
&НаКлиенте
Procedure Attachable_ExecuteToolsCommonCommand(Команда) 
	UT_CommonClient.Attachable_ExecuteToolsCommonCommand(ЭтотОбъект, Команда);
EndProcedure



///////////////////////////////////////////////////////////////////////////////
// ПРЕДОПРЕДЕЛЁННЫЕ ОБРАБОТЧИКИ ФОРМЫ

&AtServer
Procedure ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)

	Для Каждого МДСправочник Из Метаданные.Справочники Цикл
		Элементы.ObjectType.СписокВыбора.Добавить(МДСправочник.Имя, МДСправочник.Синоним);
	EndDo;
	МДНезависимый = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.Независимый;
	Для Каждого МДРегистрСведений Из Метаданные.РегистрыСведений Цикл
		Если МДРегистрСведений.РежимЗаписи = МДНезависимый Тогда
			Элементы.RegisterTypeName.СписокВыбора.Добавить(МДРегистрСведений.Имя, МДРегистрСведений.Синоним);
		EndIf;
	EndDo;

	Типы = Новый Массив;
	ВидыТипов = Новый Структура("Справочники,Документы");
	Для Каждого КлючИЗначение Из ВидыТипов Цикл
		Для Каждого ОбъектМетаданных Из Метаданные[КлючИЗначение.Ключ] Цикл
			Если ОбъектМетаданных.ТабличныеЧасти.Количество() Тогда
				Типы.Добавить(Тип(СтрЗаменить(ОбъектМетаданных.ПолноеИмя(), ".", "Ссылка.")));
			EndIf;
		EndDo;
	EndDo;

	Элементы.SourceRef.ОграничениеТипа = Новый ОписаниеТипов(Типы);

	Object.ImportMode           = мВосстановитьЗначение("ImportMode");
	Object.RegisterTypeName         = мВосстановитьЗначение("RegisterTypeName");
	Object.CatalogObjectType   = мВосстановитьЗначение("CatalogObjectType");
	Object.SourceRef         = мВосстановитьЗначение("SourceRef");

	УстановитьСписокТабличныхЧастей();

	ТабличнаяЧастьИсточника = мВосстановитьЗначение("SourceTabularSection");

	Инициализация();

	УстановитьИсточник();

	ОбновитьДанныеТабличногоДокументаСервер();
	
	UT_Common.ToolFormOnCreateAtServer(ЭтотОбъект, Отказ, СтандартнаяОбработка);

EndProcedure

&НаКлиенте
Procedure ПриОткрытии(Отказ)
	СисИнфо = Новый СистемнаяИнформация;
	Если Лев(СисИнфо.ВерсияПриложения, 3) = "8.3" Тогда
		Выполнить ("Элементы.SourceRef.ОтображениеКнопкиВыбора = ОтображениеКнопкиВыбора.ОтображатьВПолеВвода;");
		Выполнить ("Элементы.ТаблицаЗагружаемыхРеквизитовЗначениеПоУмолчанию.ОтображениеКнопкиВыбора = ОтображениеКнопкиВыбора.ОтображатьВПолеВвода;");
	EndIf;

	УправлениеВидимостью();
EndProcedure

&НаКлиенте
Procedure ПриЗакрытии()
	ПриЗакрытииНаСервере();
EndProcedure


///////////////////////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ ЭЛЕМЕНТОВ ФОРМЫ

&НаКлиенте
Procedure ImportModeOnChange(Элемент)
	Object.CatalogObjectType	= Undefined;
	Object.SourceRef			= Undefined;
	Object.RegisterTypeName			= Undefined;
	Object.SourceTabularSection	= Undefined;
	УстановитьСписокТабличныхЧастей();
	УстановитьИсточник();
	УправлениеВидимостью();
EndProcedure

&НаКлиенте
Procedure ObjectTypeOnChange(Элемент)
	УстановитьИсточник();
	УправлениеВидимостью();
EndProcedure

&НаКлиенте
Procedure ObjectTypeOpening(Элемент, СтандартнаяОбработка)
	СтандартнаяОбработка = False;
	Если ПустаяСтрока(Object.CatalogObjectType) Тогда
		Return;
	EndIf;

	Форма = ПолучитьФорму("Справочник." + Object.CatalogObjectType + ".ФормаСписка");
	Форма.Открыть();
EndProcedure

&НаКлиенте
Procedure SourceRefOnChange(Элемент)
	УстановитьСписокТабличныхЧастей();
	УстановитьИсточник();
EndProcedure

&НаКлиенте
Procedure SourceTabularSectionOnChange(Элемент)
	УстановитьИсточник();
	УправлениеВидимостью();
EndProcedure

&НаКлиенте
Procedure RegisterTypeNameOnChange(Элемент)
	УстановитьИсточник();
	УправлениеВидимостью();
EndProcedure

&НаКлиенте
Procedure RegisterTypeNameOpening(Элемент, СтандартнаяОбработка)
	СтандартнаяОбработка = False;
	Если ПустаяСтрока(Object.RegisterTypeName) Тогда
		Return;
	EndIf;

	Форма = ПолучитьФорму("РегистрСведений." + Object.RegisterTypeName + ".ФормаСписка");
	Форма.Открыть();
EndProcedure

///////////////////////////////////////////////////////////////////////////////
// ОБРАБОТЧИКИ ТАБЛИЦЫ ЗНАЧЕНИЙ ЗАГРУЖАЕМЫХ РЕКВИЗИТОВ

&НаКлиенте
Procedure ImportedAttributesTableTypeDescriptionStartChoice(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	ТекДанные = Элементы.ImportedAttributesTable.ТекущиеДанные;
	Элемент.AvailableTypes = ТекДанные.AvailableTypes;
EndProcedure

&НаКлиенте
Procedure ImportedAttributesTableAdditionalConditionsPresentationStartChoice(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	ТекДанные = Элементы.ImportedAttributesTable.ТекущиеДанные;
	СтандартнаяОбработка = False;
	Если ТекДанные.ImportMode = "Вычислять" Тогда
		ФормаРедактированияВыражения = ПолучитьФорму(DataProcessorID() + ".Форма.ФормаРедактированияВыражения", ,
			ЭтаФорма);

		ПолеТекстовогоДокумента = ФормаРедактированияВыражения.ПолеТекстовогоДокумента;
		ПолеТекстовогоДокумента.УстановитьТекст(ТекДанные.Выражение);

		ФормаРедактированияВыражения.Открыть();
		//Если ФормаРедактированияВыражения.Open() = True Тогда
		//	ТекДанные.Expression = ПолеТекстовогоДокумента.ПолучитьТекст();
		//EndIf;
	Иначе
		ДоступныеТипы	= ТекДанные.TypeDescription;
		СписокВыбораВладельца	= ПолучитьСписокВыбораСвязиПоВладельцу(ТекДанные.AttributeName);
		ФормаРедактированияСвязи = ПолучитьФорму(DataProcessorID() + ".Форма.ФормаРедактированияСвязи", ,
			ЭтаФорма);
		ФормаРедактированияСвязи.ИспользуемыеТипы = ДоступныеТипы;
		ФормаРедактированияСвязи.SearchBy = ТекДанные.SearchBy;
		ФормаРедактированияСвязи.ИспользоватьВладельца = (СписокВыбораВладельца.Количество() > 0);
		ФормаРедактированияСвязи.LinkByOwner = ТекДанные.LinkByOwner;

		СписокВыбораИскатьПо = ПолучитьСписокИменПредставлений(ТекДанные.ОписаниеТипов);
		Сп = ФормаРедактированияСвязи.Элементы.SearchBy.СписокВыбора;
		Сп.Очистить();
		Для Каждого ЭлСписка Из СписокВыбораИскатьПо Цикл
			Сп.Добавить(ЭлСписка.Значение, ЭлСписка.Представление);
		EndDo;

		Сп = ФормаРедактированияСвязи.Элементы.LinkByOwner.СписокВыбора;
		Сп.Очистить();
		Для Каждого ЭлСписка Из СписокВыбораВладельца Цикл
			Сп.Добавить(ЭлСписка.Значение, ЭлСписка.Представление);
		EndDo;
		ФормаРедактированияСвязи.Открыть();
		//Если ФормаРедактированияСвязи.Open() = True Тогда
		//	ТекДанные.SearchBy = ФормаРедактированияСвязи.SearchBy;
		//	ТекДанные.LinkByOwner = ФормаРедактированияСвязи.LinkByOwner;
		//EndIf;
	EndIf;
	//Если ТекДанные.ImportMode = "Вычислять" Тогда
	//	ТекДанные.AdditionalConditionsPresentation = ТекДанные.Expression;
	//Иначе
	//	ТекДанные.AdditionalConditionsPresentation = ?(ПустаяСтрока(ТекДанные.SearchBy), "", "Искать по "+ТекДанные.SearchBy)
	//			+?(ПустаяСтрока(ТекДанные.LinkByOwner), "", " по владельцу "+ТекДанные.LinkByOwner);
	//EndIf;
EndProcedure

&НаКлиенте
Procedure ImportedAttributesTableAdditionalConditionsPresentationClearing(Элемент, СтандартнаяОбработка)
	ТекДанные = Элементы.ImportedAttributesTable.ТекущиеДанные;
	ТекДанные.AdditionalConditionsPresentation = "";
	ТекДанные.SearchBy = "";
	ТекДанные.LinkByOwner = "";
EndProcedure

&НаКлиенте
Procedure ImportedAttributesTableImportModeOnChange(Элемент)
	ТекДанные = Элементы.ImportedAttributesTable.ТекущиеДанные;
	Если ТекДанные.ImportMode = "Вычислять" Тогда
		ТекДанные.AdditionalConditionsPresentation = ТекДанные.Expression;
	Иначе
		ТекДанные.AdditionalConditionsPresentation = ?(ПустаяСтрока(ТекДанные.SearchBy), "", "Искать по " + ТекДанные.SearchBy)
			+ ?(ПустаяСтрока(ТекДанные.СвязьПоВладельцу), "", " по владельцу " + ТекДанные.LinkByOwner);
	EndIf;
EndProcedure

&НаКлиенте
Procedure ОбработкаВыбора(ВыбранноеЗначение, ИсточникВыбора)
	Если ТипЗнч(ВыбранноеЗначение) = Тип("Структура") Тогда

		Если ВыбранноеЗначение.Источник = "ФормаРедактированияСобытий" И ВыбранноеЗначение.Результат = True Тогда
			Object.BeforeWriteObject		= ВыбранноеЗначение.BeforeWriteObject;
			Object.OnWriteObject			= ВыбранноеЗначение.OnWriteObject;
			Object.AfterAddRow	= ВыбранноеЗначение.AfterAddRow;
		ElsIf ВыбранноеЗначение.Источник = "ФормаРедактированияВыражения" И ВыбранноеЗначение.Результат = True Тогда
			ТекДанные = Элементы.ImportedAttributesTable.ТекущиеДанные;
			ТекДанные.Expression = ВыбранноеЗначение.Expression;
			ТекДанные.AdditionalConditionsPresentation = ТекДанные.Expression;
		ElsIf ВыбранноеЗначение.Источник = "ФормаРедактированияСвязи" И ВыбранноеЗначение.Результат = True Тогда
			ТекДанные = Элементы.ImportedAttributesTable.ТекущиеДанные;
			ТекДанные.SearchBy = ВыбранноеЗначение.SearchBy;
			ТекДанные.LinkByOwner = ВыбранноеЗначение.LinkByOwner;
			ТекДанные.AdditionalConditionsPresentation = ?(ПустаяСтрока(ТекДанные.SearchBy), "", "Искать по "
				+ ТекДанные.SearchBy) + ?(ПустаяСтрока(ТекДанные.СвязьПоВладельцу), "", " по владельцу "
				+ ТекДанные.LinkByOwner);
		EndIf;

	EndIf;
EndProcedure
